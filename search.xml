<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux kernel]]></title>
    <url>%2F2019%2F01%2F03%2Flinux%20kernel%2F</url>
    <content type="text"><![CDATA[kernel introduce 内核是操作系统的核心，掌控着所有硬件设备的控制权。也就是说，你所希望计算机帮你完成的各项工作，都需要通过内核的帮助才能完成。内核可以分为以下几种设计流派： 单内核(monolithic kernel)： Linux把所有功能集成于同一个程序微内核(micro kernel)：Windows, Solaris每种功能使用一个单独子系统实现内核 Linux内核特点： 支持模块化：.ko（内核对象) 如：文件系统，硬件驱动，网络协议等 支持内核模块的动态装载和卸载 组成部分： 核心文件：/boot/vmlinuz-VERSION-releaseramdisk：辅助的伪根系统 CentOS 5: /boot/initrd-VERSION-release.imgCentOS 6,7: /boot/initramfs-VERSION-release.img 模块文件：/lib/modules/VERSION-release kernel 自身初始化检测可识别到的所有硬件设备加载硬件驱动程序（借助于ramdisk加载驱动）以只读方式挂载根文件系统运行用户空间的第一个应用程序：/sbin/init启动流程 ramdisk：内核中的特性之一：使用缓冲和缓存来加速对磁盘上的文件访问，并加载相应的硬件驱动 CentOS 5: initrd 工具程序：mkinitrdCentOS 6，7: initramfs工具程序：mkinitrd, dracut ramdisk文件的制作 mkinitrd命令 为当前正在使用的内核重新制作ramdisk文件 1mkinitrd /boot/initramfs-$(uname -r).img $(uname -r) dracut命令 为当前正在使用的内核重新制作ramdisk文件 1dracut /boot/initramfs-$(uname -r).img $(uname -r) 内核版本uname命令uname - print system informationuname [OPTION]…-r: 显示VERSION-RELEASE-n: 显示主机名-a:显示所有信息 123456[root@CentOS6 ~]#uname -r2.6.32-754.el6.x86_64[root@CentOS6 ~]#uname -nCentOS6.localdomain[root@CentOS6 ~]#uname -aLinux CentOS6.localdomain 2.6.32-754.el6.x86_64 #1 SMP Tue Jun 19 21:26:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux uname -a 现实的内容依次为： Linux 操作系统类型 CentOS6.localdomain 操作系统的主机名 2.6.32-754.el6.x86_64 内核版本信息 #1 SMP Tue Jun 19 21:26:04 UTC 2018 内核的编译日期 x86_64 x86_64 x86_64 这三组分别是：操作系统版本、处理器类型、硬件平台 GNU/Linux 操作系统名称 /proc目录该目录是系统与内核交互的一个伪文件系统接口，内核把自己内部状态信息及统计信息，以及可配置参数通过proc伪文件系统加以输出。 参数 只读：输出信息 1234567[root@CentOS6 ~]#cat /proc/sys/net/ipv4/icmp_echo_ignore_all 0[root@CentOS6 ~]#ping 192.168.183.157PING 192.168.183.157 (192.168.183.157) 56(84) bytes of data.64 bytes from 192.168.183.157: icmp_seq=1 ttl=64 time=0.074 ms64 bytes from 192.168.183.157: icmp_seq=2 ttl=64 time=0.068 ms64 bytes from 192.168.183.157: icmp_seq=3 ttl=64 time=0.069 ms 可写：可接受用户指定“新值”来实现对内核某功能或特性的配置,不支持编辑器编辑 12345678[root@CentOS6 ~]#echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all[root@CentOS6 ~]#cat /proc/sys/net/ipv4/icmp_echo_ignore_all1[root@CentOS6 ~]#ping -wl -c1 192.168.183.157PING 192.168.183.157 (192.168.183.157) 56(84) bytes of data. --- 192.168.183.157 ping statistics ---1 packets transmitted, 0 received, 100% packet loss, time 10001ms 1/proc/sys echo命令通过重定向方式也可以修改大多数参数的值 echo “VALUE” &gt; /proc/sys/path/to/parameter echo “websrv” &gt; /proc/sys/kernel/hostname sysctl命令用于查看或设定此目录中诸多参数 sysctl -w path.to.parameter=VALUE sysctl -w kernel.hostname=mail.magedu.com sysctl命令默认配置文件：/etc/sysctl.conf 设置某参数 sysctl -w parameter=VALUE 通过读取配置文件设置参数 sysctl -p [/path/to/conf_file] 查看所有生效参数 sysctl -a 123456[root@CentOS6 ~]#sysctl -a |lesskernel.sched_child_runs_first = 0kernel.sched_min_granularity_ns = 2000000kernel.sched_latency_ns = 10000000kernel.sched_wakeup_granularity_ns = 2000000kernel.sched_tunable_scaling = 1 常用的几个参数： net.ipv4.ip_forward net.ipv4.icmp_echo_ignore_all vm.drop_caches /sys目录sysfs：为用户使用的伪文件系统，输出内核识别出的各硬件设备的相关属性信息，也有内核对硬件特性的设定信息；有些参数是可以修改的，用于调整硬件工作特性udev通过此路径下输出的信息动态为各设备创建所需要设备文件，udev是运行用户空间程序专用工具：udevadmin, hotplugudev为设备创建设备文件时，会读取其事先定义好的规则文件，一般在/etc/udev/rules.d及/usr/lib/udev/rules.d目录下 12345678910111213网卡[root@CentOS6 ~]#cat /etc/udev/rules.d/70-persistent-net.rules# This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.# PCI device 0x8086:0x100f (e1000)SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR&#123;address&#125;=="00:0c:29:bf:4b:56", ATTR&#123;type&#125;=="1", KERNEL=="eth*", NAME="eth0"# PCI device 0x8086:0x100f (e1000)SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR&#123;address&#125;=="00:0c:29:bf:4b:60", ATTR&#123;type&#125;=="1", KERNEL=="eth*", NAME="eth1" 内核模块管理查看当前内核已经装载的模块 lsmod123456789101112131415[root@CentOS6 ~]#lsmodModule Size Used byrfcomm 71207 4 sco 17589 2 bridge 85770 0 bnep 16370 2 l2cap 54498 16 rfcomm,bnepautofs4 27000 3 8021q 20507 0 garp 7184 1 8021qstp 2218 2 bridge,garpllc 5450 3 bridge,garp,stpipt_REJECT 2383 2 nf_conntrack_ipv4 9218 2 ...省略... 查看内核模块的文件/proc/modules123456789101112131415[root@CentOS6 ~]#cat /proc/modules rfcomm 71207 4 - Live 0xffffffffa05fd000sco 17589 2 - Live 0xffffffffa05f3000bridge 85770 0 - Live 0xffffffffa05d5000bnep 16370 2 - Live 0xffffffffa05cd000l2cap 54498 16 rfcomm,bnep, Live 0xffffffffa05b9000autofs4 27000 3 - Live 0xffffffffa05ad0008021q 20507 0 - Live 0xffffffffa05a2000garp 7184 1 8021q, Live 0xffffffffa059c000stp 2218 2 bridge,garp, Live 0xffffffffa0598000llc 5450 3 bridge,garp,stp, Live 0xffffffffa0592000ipt_REJECT 2383 2 - Live 0xffffffffa0567000nf_conntrack_ipv4 9218 2 - Live 0xffffffffa0560000nf_defrag_ipv4 1483 1 nf_conntrack_ipv4, Live 0xffffffffa055c000...省略... 查看模块的详细描述信息 modinfomodinfo [ -k kernel ] [ modulename|filename… ]-n：只显示模块文件路径-p：显示模块参数-a：作者-d：描述 123456789[root@CentOS6 ~]#modinfo xfsfilename: /lib/modules/2.6.32-754.el6.x86_64/kernel/fs/xfs/xfs.kolicense: GPLdescription: SGI XFS with ACLs, security attributes, large block/inode numbers, no debug enabledauthor: Silicon Graphics, Inc.retpoline: Ysrcversion: 032C69ECC93FCBD7B47F691depends: exportfsvermagic: 2.6.32-754.el6.x86_64 SMP mod_unload modversions 内核模块装载或卸载 modprobe装载模块：modprobe MOD_NAME (注意这里会自动解决模块间的依赖关系)卸载模块：modprobe -r modulename 手动实现模块文件的装载和卸载insmod命令：insmod /path/to/module_file(注意这里不会自动解决模块间的依赖关系)rmmod命令:rmmod MOD_NAME 编译内核前提： 准备好开发环境 获取目标主机上硬件设备的相关信息 获取目标主机系统功能的相关信息 例如:需要启用相应的文件系统 获取内核源代码包 www.kernel.org 开发环境准备 包组 1234Development Toolsncurses-develelfutils-libelf-developenssl-devel 目标主机硬件设备相关信息 CPU： cat /proc/cpuinfox86info -alscpu PCI设备： lspci -v-vv lsusb -v-vv lsblk 块设备 3.了解全部硬件设备信息hal-device：CentOS 6 内核编译安装系统 安装开发包组 下载源码文件 .config：准备文本配置文件 make menuconfig：配置内核选项 make [-j #] make modules_install：安装模块 make install: 安装内核相关文件 ​安装bzImage为/boot/vmlinuz-VERSION-RELEASE ​生成initramfs文件 ​编辑grub的配置文件 12345678910编译安装内核示例tar xf linux-3.10.67.tar.xz -C /usr/srccd /usr/src/linux-3.10.67 cp /boot/config-$(uname -r) ./.configmake help make menuconfig make -j 2 make modules_installmake install reboot 卸载内核 make clean：清理大多数编译生成的文件，但会保留config文件等 make mrproper: 清理所有编译生成的文件、 config及某些备份文件 make distclean：mrproper、清理patches以及编辑器备份文件卸载内核 删除/lib/modules/目录下不需要的内核库文件 删除/usr/src/linux/目录下不需要的内核源码 删除/boot目录下启动的内核和内核映像文件 更改grub的配置文件，删除不需要的内核启动列表]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统启动流程与grub]]></title>
    <url>%2F2019%2F01%2F03%2F%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B8%8Egrub%2F</url>
    <content type="text"><![CDATA[Centos6启动流程 POST加电自检,即加载BIOS的硬件信息，获取第一个启动设备 读取第一个启动设备MBR的引导加载程序(grub)的启动信息 加载核心操作系统的核心信息，核心开始解压缩，并尝试驱动所有的硬件设备 核心执行init程序，并获取默认的运行信息 init程序执行/etc/rc.d/rc.sysinit文件 启动核心的外挂模块 init执行运行的各个批处理文件(scripts) 执行/bin/login程序，等待用户登录 登录之后开始以Shell控制主机启动流程 加电自检：power on system test(POST) 自检主要是检测一下硬件设备是否存在并能正常运行，如：CPU、内存、硬盘是否存在并能正常运行。这些自检的功能是有一个软件程序来实现的，这个软件程序叫做：BIOS。BIOS （Basic Input Output System）即基本输入输出系统。它是装载在一个硬件芯片CMOS之上，显然CMOS是一个硬件设备。加电过程就是给CMOS通电，然后启动其上的BIOS程序，BIOS程序会根据CMOS上面的一些配置信息去读取其他的硬件设备信息并检测其是否存在并能正常运行，之后进行硬件设备的初始化。 读取MBR 众所周知，硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。前446字节存放grub的空间，中间64字节是分区表，最后2字节 55AA的标识。系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader。Boot Loader 就是在操作系统内核运行之前运行的一段小程序。 Grub启动引导阶段 grub引导也分为三个阶段stage1阶段、stage1.5阶段和stage2阶段。 阶段 1 如上文 POST（上电自检）阶段提到的，在 POST 阶段结束时，BIOS 将查找在接入的磁盘中查找引导记录，其通常位于 MBR（主引导记录Master Boot Record），它加载它找到的第一个引导记录中到内存中，并开始执行此代码。引导代码（及阶段 1 代码）必须非常小，因为它必须连同分区表放到硬盘的第一个 512 字节的扇区中。 在传统的常规 MBR 中，引导代码实际所占用的空间大小为 446 字节。这个阶段 1 的 446 字节的文件通常被叫做引导镜像（boot.img），其中不包含设备的分区信息，分区是一般单独添加到引导记录中。 由于引导记录必须非常的小，它不可能非常智能，且不能理解文件系统结构。因此阶段 1 的唯一功能就是定位并加载阶段 1.5 的代码。为了完成此任务，阶段 1.5 的代码必须位于引导记录与设备第一个分区之间的位置。在加载阶段 1.5 代码进入内存后，控制权将由阶段 1 转移到阶段 1.5。 阶段 1.5 如上所述，阶段 1.5 的代码必须位于引导记录与设备第一个分区之间的位置。该空间由于历史上的技术原因而空闲。第一个分区的开始位置在扇区 63 和 MBR（扇区 0）之间遗留下 62 个 512 字节的扇区（共 31744 字节），该区域用于存储阶段 1.5 的代码镜像 core.img 文件。该文件大小为 25389 字节，故此区域有足够大小的空间用来存储 core.img。 因为有更大的存储空间用于阶段 1.5，且该空间足够容纳一些通用的文件系统驱动程序，如标准的 EXT 和其它的 Linux 文件系统，如 FAT 和 NTFS 等。故阶段 2 的文件可以存放于 /boot 文件系统中，一般在 /boot/grub 目录下。 注意 /boot 目录必须放在一个 GRUB 所支持的文件系统（并不是所有的文件系统均可）。阶段 1.5 的功能是开始执行存放阶段 2 文件的 /boot 文件系统的驱动程序，并加载相关的驱动程序。 阶段 2 GRUB 阶段 2 所有的文件都已存放于 /boot/grub 目录及其几个子目录之下。该阶段没有一个类似于阶段 1 与阶段 1.5 的镜像文件。相应地，该阶段主要需要从 /boot/grub2/i386-pc 目录下加载一些内核运行时模块。 GRUB 阶段 2 的主要功能是定位和加载 Linux 内核到内存中，并转移控制权到内核。内核的相关文件位于 /boot 目录下，这些内核文件可以通过其文件名进行识别，其文件名均带有前缀 vmlinuz。你可以列出 /boot 目录中的内容来查看操作系统中当前已经安装的内核。 Red Hat 包管理器（DNF）支持保留多个内核版本，以防最新版本内核发生问题而无法启动时，可以恢复老版本的内核。默认情况下，GRUB 提供了一个已安装内核的预引导菜单，其中包括问题诊断菜单（recuse）以及恢复菜单（如果配置已经设置恢复镜像）。 阶段 2 加载选定的内核到内存中，并转移控制权到内核代码。 加载内核 根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。 用户层init依据inittab文件来设定运行等级 内核被加载后，第一个运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。 123456789101112131415161718192021222324252627[root@CentOS6 rc5.d]#cat /etc/inittab# inittab is only used by upstart for the default runlevel.# ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## System initialization is started by /etc/init/rcS.conf## Individual runlevels are started by /etc/init/rc.conf## Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf## Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,# with configuration in /etc/sysconfig/init.## For information on how to write upstart event handlers, or how# upstart works, see init(5), init(8), and initctl(8).## Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)# id:5:initdefault: 其实/etc/inittab文件最主要的作用就是设定Linux的运行等级， 运行级别：为系统运行或维护等目的而设定；0-6：7个级别 0：关机 1：单用户模式(root自动登录), single, 维护模式 2：多用户模式，启动网络功能，但不会启动NFS；维护模式 3：多用户模式，正常模式；文本界面 4：保留，未使用 5：多用户模式，正常模式；图形界面 6：重启 默认级别：3, 5 切换级别：init # 查看级别：runlevel ; who -r 每一行格式： 1id:runlevel:action:process id：是惟一标识该项的字符序列 runlevels： 定义了操作所使用的运行级别 action： 指定了要执行的特定操作 wait: 切换至此级别运行一次respawn：此process终止，就重新启动之initdefault：设定默认运行级别；process省略sysinit：设定系统初始化方式 process：定义了要执行的进程 故 id:5:initdefault: 这就表明Linux需要开机运行在5模式 破解CentOS5和6的root口令进入单用户模式即可 init进程执行rc.sysinit/etc/rc.d/rc.sysinit: 系统初始化脚本（一般情况下，我们不需要改） 设置主机名 设置欢迎信息 激活udev和selinux 挂载/etc/fstab文件中定义的文件系统 检测根文件系统，并以读写方式重新挂载根文件系统 设置系统时钟 激活swap设备 根据/etc/sysctl.conf文件设置内核参数 激活lvm及software raid设备 加载额外设备的驱动程序 清理操作启动流程 执行不同运行级别的脚本程序根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。说明：rc N –&gt; 意味着读取/etc/rc.d/rcN.d/12345678910111213[root@CentOS6 rc.d]#lltotal 60drwxr-xr-x. 2 root root 4096 Nov 6 09:32 init.d-rwxr-xr-x. 1 root root 2617 Jun 20 00:12 rcdrwxr-xr-x. 2 root root 4096 Oct 30 20:19 rc0.ddrwxr-xr-x. 2 root root 4096 Oct 30 20:19 rc1.ddrwxr-xr-x. 2 root root 4096 Oct 30 20:19 rc2.ddrwxr-xr-x. 2 root root 4096 Oct 30 20:19 rc3.ddrwxr-xr-x. 2 root root 4096 Oct 30 20:19 rc4.ddrwxr-xr-x. 2 root root 4096 Nov 7 11:26 rc5.ddrwxr-xr-x. 2 root root 4096 Oct 30 20:19 rc6.d-rwxr-xr-x. 1 root root 220 Jun 20 00:12 rc.local-rwxr-xr-x. 1 root root 20199 Jun 20 00:12 rc.sysinit K: K##：##运行次序；数字越小，越先运行；数字越小的服务，通常为依赖到别的服务S: S##：##运行次序；数字越小，越先运行；数字越小的服务，通常为被依赖到的服务 123456for srv in /etc/rc.d/rcN.d/K*; do$srv stopdonefor srv in /etc/rc.d/rcN.d/S*; do$srv startdone 执行/etc/rc.d/rc.local你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然： 12345678[root@CentOS6 rc.d]#cat /etc/rc.d/rc.local #!/bin/sh## This script will be executed *after* all the other init scripts.# You can put your own initialization stuff in here if you don't# want to do the full Sys V style init stuff.touch /var/lock/subsys/local 注意：正常级别下，最后启动一个服务S99local没有链接至/etc/rc.d/init.d一个服务脚本，而是指向了/etc/rc.d/rc.local脚本不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录，且又想开机时自动运行的命令，可直接放置于/etc/rc.d/rc.local文件中/etc/rc.d/rc.local在指定运行级别脚本后运行可以根据情况，进行自定义修改 执行/bin/login程序，进入登录状态此时，系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。 GrubGrub: GRand Unified Bootloader如前面所述，grub分为三个阶段stage1: mbrstage1.5: mbr之后的扇区，让stage1中的bootloader能识别stage2所在的分区上的文件系统stage2：磁盘分区(/boot/grub/) Grub安装 grub-install 安装grub stage1和stage1_5到/dev/DISK磁盘上，并复制GRUB相关文件 到 DIR/boot目录下 grub-install –root-directory=DIR /dev/DISK grub grub&gt; root (hd#,#) grub&gt; setup (hd#)grub 识别硬盘设备 (hd#,#) hd#: 磁盘编号，用数字表示；从0开始编号 #: 分区编号，用数字表示; 从0开始编号 (hd0,0) 第一块硬盘，第一个分区 123456789101112131415161718192021222324252627282930313233343536[root@CentOS6 ~]#dd if=/dev/zero of=/dev/sda bs=1 count=446446+0 records in446+0 records out446 bytes (446 B) copied, 0.00308127 s, 145 kB/s[root@CentOS6 ~]#hexdump -C /dev/sda -n 51200000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|*000001b0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 20 |............... |000001c0 21 00 83 aa 28 82 00 08 00 00 00 00 20 00 00 aa |!...(....... ...|000001d0 29 82 83 fe ff ff 00 08 20 00 00 80 1a 06 00 fe |)....... .......|000001e0 ff ff 83 fe ff ff 00 88 3a 06 00 80 a9 03 00 fe |........:.......|000001f0 ff ff 05 fe ff ff 00 08 e4 09 00 f8 1b 0f 55 aa |..............U.|00000200[root@CentOS6 ~]#grubProbing devices to guess BIOS drives. This may take a long time. GNU GRUB version 0.97 (640K lower / 3072K upper memory) [ Minimal BASH-like line editing is supported. For the first word, TAB lists possible command completions. Anywhere else TAB lists the possible completions of a device/filename.]grub&gt; root (hd0,0) root (hd0,0) Filesystem type is ext2fs, partition type 0x83grub&gt; setup (hd0)setup (hd0) Checking if "/boot/grub/stage1" exists... no Checking if "/grub/stage1" exists... yes Checking if "/grub/stage2" exists... yes Checking if "/grub/e2fs_stage1_5" exists... yes Running "embed /grub/e2fs_stage1_5 (hd0)"... 27 sectors are embedded.succeeded Running "install /grub/stage1 (hd0) (hd0)1+27 p (hd0,0)/grub/stage2 /grub/grub.conf"... succeededDone.grub&gt; 如果我们把/boot/grub/* 的文件移走 123456789101112131415161718192021222324252627282930313233343536373839404142[root@CentOS6 ~]#mv /boot/grub/* /data[root@CentOS6 ~]#dd if=/dev/zero of=/dev/sda bs=1 count=446446+0 records in446+0 records out446 bytes (446 B) copied, 0.00398936 s, 112 kB/s[root@CentOS6 ~]#hexdump -C /dev/sda -n 51200000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|*000001b0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 20 |............... |000001c0 21 00 83 aa 28 82 00 08 00 00 00 00 20 00 00 aa |!...(....... ...|000001d0 29 82 83 fe ff ff 00 08 20 00 00 80 1a 06 00 fe |)....... .......|000001e0 ff ff 83 fe ff ff 00 88 3a 06 00 80 a9 03 00 fe |........:.......|000001f0 ff ff 05 fe ff ff 00 08 e4 09 00 f8 1b 0f 55 aa |..............U.|00000200[root@CentOS6 ~]#grubProbing devices to guess BIOS drives. This may take a long time. GNU GRUB version 0.97 (640K lower / 3072K upper memory) [ Minimal BASH-like line editing is supported. For the first word, TAB lists possible command completions. Anywhere else TAB lists the possible completions of a device/filename.]grub&gt; root (hd0,0)root (hd0,0) Filesystem type is ext2fs, partition type 0x83grub&gt; setup (hd0)setup (hd0) Checking if "/boot/grub/stage1" exists... no Checking if "/grub/stage1" exists... noError 15t: File not foundgrub&gt; [root@CentOS6 ~]#grub-install /dev/sdaProbing devices to guess BIOS drives. This may take a long time.Installation finished. No error reported.This is the contents of the device map /boot/grub/device.map.Check if this is correct or not. If any of the lines is incorrect,fix it and re-run the script `grub-install'.(fd0) /dev/fd0(hd0) /dev/sda 由此实验我们可以看出grub&gt; root (hd#,#)；grub&gt; setup (hd#)这种修复方法依赖于/boot/grub/ 文件而grub-install这种修复方法不依赖/boot/grub/ 文件，感觉更通用一些。 grubstage2及内核等通常放置于一个基本磁盘分区功用： 提供启动菜单、并提供交互式接口 a：内核参数e: 编辑模式，用于编辑菜单c: 命令模式，交互式接口 加载用户选择的内核或操作系统 允许传递参数给内核可隐藏启动菜单 为菜单提供了保护机制 为编辑启动菜单进行认证为启用内核或操作系统进行认证grub legacy grub的命令行接口 help: 获取帮助列表 help KEYWORD: 详细帮助信息 find (hd#,#)/PATH/TO/SOMEFILE： root (hd#,#) kernel /PATH/TO/KERNEL_FILE: 设定本次启动时用到的内核文件；额外还可添加许多内核支持使用的cmdline参数 例如：max_loop=100 selinux=0 init=/path/to/init initrd /PATH/TO/INITRAMFS_FILE: 设定为选定的内核提供额外文件的ramdisk boot: 引导启动选定的内核 cat /proc/cmdline 内核参数 12[root@CentOS6 ~]#cat /proc/cmdline ro root=UUID=d3df2aba-5cd3-47fe-8128-3445b87dba11 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet 手动在grub命令行接口启动系统 1234grub&gt; root (hd#,#)grub&gt; kernel /vmlinuz-VERSION-RELEASE ro root=/dev/DEVICEgrub&gt; initrd /initramfs-VERSION-RELEASE.imggrub&gt; bootgrub legacy配置文件 配置文件: /boot/grub/grub.conf &lt;- /etc/grub.conf1234567891011121314151617181920[root@CentOS6 ~]#vim /boot/grub/grub.conf# grub.conf generated by anaconda ## Note that you do not have to rerun grub after making changes to this file# NOTICE: You have a /boot partition. This means that# all kernel and initrd paths are relative to /boot/, eg.# root (hd0,0)# kernel /vmlinuz-version ro root=/dev/sda2# initrd /initrd-[generic-]version.img#boot=/dev/sdadefault=0timeout=5splashimage=(hd0,0)/grub/splash.xpm.gzhiddenmenutitle CentOS 6 (2.6.32-754.el6.x86_64) root (hd0,0) kernel /vmlinuz-2.6.32-754.el6.x86_64 ro root=UUID=d3df2aba-5cd3-47fe-8128-3445b87dba11 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet initrd /initramfs-2.6.32-754.el6.x86_64.img 参数：default=#: 设定默认启动的菜单项；落单项(title)编号从0开始timeout=#：指定菜单项等待选项选择的时长splashimage=(hd#,#)/PATH/XPM_FILE：菜单背景图片文件路径password [–md5] STRING: 启动菜单编辑认证hiddenmenu：隐藏菜单title TITLE：定义菜单项“标题” , 可出现多次root (hd#,#)：查找stage2及kernel文件所在设备分区；为grub的根kernel /PATH/TO/VMLINUZ_FILE [PARAMETERS]：启动的内核initrd /PATH/TO/INITRAMFS_FILE: 内核匹配的ramfs文件 grub加密因为linux只要进入单用户模式下就很轻易的破解root口令，所以我们在/boot/grub/grub.conf文件里加上一行passwd.password [–md5|–encrypted ] STRING: 启动选定的内核或操作系统时进行认证 生成grub口令 12grub-md5-cryptgrub-crypt 破解root口令 启动系统时，设置其运行级别1，进入单用户模式： 编辑grub菜单(选定要编辑的title，而后使用a 或 e 命令)在选定的kernel后附加1, s, S，single 都可以在kernel所在行，键入“b” 命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>启动流程</tag>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本三剑客之sed]]></title>
    <url>%2F2019%2F01%2F03%2F%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bsed%2F</url>
    <content type="text"><![CDATA[概述&ensp;&ensp;&ensp;&ensp;sed是一种流编辑器、行编辑器。它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’ 的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。&ensp;&ensp;&ensp;&ensp;sed和我们之前的文本处理工具vim、grep是有区别的，vim是一种交互式的文本编辑工具，而sed是一种非交互式的文本编辑器（通过给定的条件自动的逐行去处理文件）；grep虽然也是一种流失的文本处理工具，但grep是用来检索条件关键字的，而sed却是搜索匹配处理文本公积&ensp;&ensp;&ensp;&ensp;sed的功能：主要用来自动编辑一个或多个文件,简化对文件的反复操作,编写转换程序等 sed语法sed [option]... &#39;script&#39; inputfile... -n 不输出模式空间内容到屏幕，即不自动打印-e 多点编辑123[root@localhost ~]#seq 10 | sed -n -e '2p' -e '6p' 26 -f /PATH/SCRIPT_FILE 从指定文件中读取编辑脚本-r 支持使用扩展正则表达式-i.bak 备份文件并原处编辑 地址定界 不给地址：对全文进行处理 1[root@localhost ~]#seq 10 | sed 'p' 单地址:#: 指定的行$： 最后一行/pattern/：被此处模式所能够匹配到的每一行 123[root@localhost ~]#seq 10 | sed -n &apos;1p&apos;[root@localhost ~]#seq 10 | sed -n &apos;$p&apos;[root@localhost ~]#sed -n &apos;/^root/p&apos; /etc/passwd 地址范围：#,##,+#/pat1/,/pat2/#,/pat1/ 1234[root@localhost ~]#seq 10 | sed -n '1,5p'[root@localhost ~]#seq 10 | sed -n '1,+4p'[root@localhost ~]#sed -n '/^b/,/^f/p' /etc/passwd[root@localhost ~]#sed -n '2,/^f/p' /etc/passwd ~：步进1~2 奇数行2~2 偶数行 12[root@localhost ~]#seq 10 | sed -n '1~2p'[root@localhost ~]#seq 10 | sed -n '2~2p' 编辑命令d 删除模式空间匹配的行，并立即启用下一轮循环12345[root@localhost ~]#seq 5 | sed '2d'1345 p 打印当前模式空间内容，追加到默认输出之后a []text 在指定行后面追加文本，支持使用\n实现多行追加12345678[root@localhost ~]#seq 5 | sed '$axxx\nyyy' 12345xxxyyy i []text 在行前面插入文本12345678[root@localhost ~]#seq 5 | sed '$ixxx\nyyy' 1234xxxyyy5 c []text 替换行为单行或多行文本 1234567[root@localhost ~]#seq 5 | sed '$cxxx\nyyy' 1234xxxyyy w /path/file 保存模式匹配的行至指定文件r /path/file 读取指定文件的文本至模式空间中匹配到的行后= 为模式空间中的行打印行号1[root@localhost ~]#sed -n &apos;/root/=&apos; /etc/passwd ! 模式空间中匹配行取反处理sed工具12[root@localhost ~]#seq 5 | sed ' 2 ! d' 2 s/// 查找替换,支持使用其它分隔符， s@@@， s###替换标记：g 行内全局替换p 显示替换成功的行 练习 删除centos7系统/etc/grub2.cfg文件中所有以空白开头的行行首的空白字符 1cat /etc/grub2.cfg | sed -nr 's@^([[:space:]]*)([[:alpha:]].*$)@\2@gp' 删除/etc/fstab文件中所有以#开头，后面至少跟一个空白字符的行的行首的#和空白字符 1cat /etc/fstab | sed -nr 's@^#[[:space:]]@@gp' 在centos6系统/root/install.log每一行行首增加#号 1cat /root/install.log | sed -nr 's@^In.*@#&amp;@g' 在/etc/fstab文件中不以#开头的行的行首增加#号 1cat /etc/fstab | sed -nr 's@^([^#]|$)@#&amp;@gp' 处理/etc/fstab路径,使用sed命令取出其目录名和基名 12dirname: echo /etc/fstab | sed -nr 's@(.*/)([^/]+/?$)@\1@gp'basename: echo /etc/fstab | sed -nr 's@(.*/)([^/]+/?$)@\2@gp' 利用sed取出ifconfig命令中本机的IPv4地址 1ifconfig | sed -nr '2!d;s@.*inet (addr:)?@@;s@ .*@@gp' 统计centos安装光盘中Package目录下的所有rpm文件的以.分隔倒数第二个字段的重复次数 1ls /run/media/root/CentOS\ 7\ x86_64/Packages/ | sed -nr 's@(.*\.)(.*)\.rpm$@\2@gp' |sort | uniq -c 统计/etc/init.d/functions文件中每个单词的出现次数，并排序（用grep和sed两种方法分别实现）12grep: cat /etc/init.d/functions | grep -Eow "[[:alpha:]]*_?" | sort | uniq -csed: 高级编辑命令&ensp;&ensp;&ensp;&ensp;sed除了模式空间外，还有一个“hold space”的内存空间，称为保持空间。&ensp;&ensp;&ensp;&ensp;sed工作机制是每次自动读取一行到模式空间中，在模式空间中完成处理，将处理结果输出至标准输出设备；在模式空间中处理一行内容后会继续处理下一行。那么对于处理过的行还有其他处理时，我们就把处理过的行送至保持空间中，然后在后续处理中在传回至模式空间中。常见命令： P： 打印模式空间开端至\n内容，并追加到默认输出之前h: 把模式空间中的内容覆盖至保持空间中H：把模式空间中的内容追加至保持空间中g: 从保持空间取出数据覆盖至模式空间G：从保持空间取出内容追加至模式空间x: 把模式空间中的内容与保持空间中的内容进行互换n: 读取匹配到的行的下一行覆盖至模式空间N：读取匹配到的行的下一行追加至模式空间d: 删除模式空间中的行D：如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环 示例 seq 10 | sed -n ‘n;p’ (1)首先-n禁止默认的打印功能，因为没有地址定界，所以默认为全文，首先读第一行至模式空间，n表示匹配到的下一行覆盖至模式空间，即用第二行覆盖模式空间内的第一行; (2)然后读取第三行，继续-n操作，所以打印出来的都为偶数行。123456[root@localhost ~]#seq 10 | sed -n 'n;p' 246810 seq 10 | sed ‘1!G;h;$!d’ (1)依然是默认为全文，首先读取第一行，1！G，不做操作，h，覆盖至保持空间，因为保持空间本开始没有内容，所以此时保持空间内容为第一行，$!d，不是最后一行，执行删除。此第一行操作完毕，此时模式空间没有内容，保持空间为第一行； (2)再读取第二行，1！G，因为不是第一行，执行G操作，即从保持空间取出内容追加至模式空间，此时模式空间的内容为第二行+第一行，且第一行在下面，h，把模式空间中的内容覆盖至保持空间中，此时保持空间为原来的模式空间内容，$!d，不是最后一行，执行删除。此时模式空间为空，保持空间为第二行+第一行。 (3)直到读到最后一行，1！G，此时模式空间内为第十行到第一行，h，再把模式空间内容覆盖至保持空间，最后$!d,因为是最后一行，所以不予操作，最后将模式空间的内容打印出来，即逆序显示。1234567891011[root@localhost ~]#seq 10 | sed '1!G;h;$!d' 10987654321 seq 10 | sed ‘$!d’默认为全文内容，$!d表示不是最后一行执行d删除操作，所以只打印出最后一行 12[root@localhost ~]#seq 10 | sed '$!d'10 将文本文件的n和n+1行合并为一行， n为奇数行 1seq 10 | sed 'N;s@\n@ @']]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>sed</tag>
        <tag>文本工具</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本处理三剑客之awk]]></title>
    <url>%2F2019%2F01%2F03%2F%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bawk%2F</url>
    <content type="text"><![CDATA[Linux文本处理工具三剑客：grep、sed、awk.其中grep是一种文本过滤工具,sed是文本行编辑器,而awk是一种报表生成器，就是对文件进行格式化处理。这里的格式化就是对文件内容进行各种“排版”，进而格式化显示。 在Linux之上我们使用的是GNU awk，简称gawk.我们通过man gawk得知gawk–模式扫描和处理语言，gawk是一种过程式编程语言。gawk还支持条件判断、数组、循环等各种编程语言中所有可以使用的功能，因此我们还可以把gwak称为一种脚本语言解释器。 基本用法： awk [options] ‘program’ var=value file… awk [options] -f programfile var=value file… awk [options] ‘BEGIN{action;… }pattern{action;… }END{action;… }’ file … awk程序可由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块，共3部分组成 program 通常是被放在单引号中 选项： -F “分隔符” 指明输入时用到的字段分隔符 -v var=value 变量赋值 awk语言 基本格式：awk [options] ‘program’ file…Program：pattern{action statements;..} pattern和action pattern部分决定动作语句何时触发及触发事件 BEGIN,END action statements对数据进行处理，放在{}内指明 print, printf 分割符、域和记录 awk执行时，由分隔符分隔的字段（域）标记1,1,2…n称为域标识。n称为域标识。0为所有域，注意：此时和shell中变量符含义不同文件的每一行称为记录省略action，则默认执行print符含义不同文件的每一行称为记录省略action，则默认执行print0 的操作 awk工作原理 第一步：执行BEGIN{action;… }语句块中的语句 第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ action;… }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。 第三步：当读至输入流末尾时，执行END{action;…}语句块 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块 pattern语句块中的通用命令是最重要的部分，也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块 awk的输出命令之一：printprint格式：print item1, item2, … item:字符串，用引号引用; print “hello”,”world” 变量：显示变量的值，也可以直接使用变量的名进行引用; print name 要点： 各item之间需要逗号分隔：而输出的分隔符为默认空白字符; 输出item可以字符串，也可是数值；当前记录的字段、变量或awk的表达式:数值会被隐士转换为字符串进行输出； 如省略item，相当于”print $0”,用于输出整行; 输出空白字符：print “ “ 示例： awk -F: ‘{print}’ /etc/passwd 等同于 awk -F: ‘{print $0}’ /etc/passwd 1234567&gt; [root@cetos7 ~]#cat /etc/passwd&gt; root:x:0:0:root:/root:/bin/bash&gt; bin:x:1:1:bin:/bin:/sbin/nologin&gt; [root@cetos7 ~]#awk -F: '&#123;print&#125;' /etc/passwd&gt; root:x:0:0:root:/root:/bin/bash&gt; bin:x:1:1:bin:/bin:/sbin/nologin&gt; awk -F: ‘{print “wang”}’ /etc/passwd 12345&gt; [root@cetos7 ~]#awk -F: '&#123;print "wang"&#125;' /etc/passwd &gt; # 以：为分隔符，打印wang&gt; wang&gt; wang&gt; awk -F: ‘{print $1}’ /etc/passwd 12345&gt; [root@cetos7 ~]#awk -F: '&#123;print $1&#125;' /etc/passwd &gt; # 以：为分隔符，打印第一列&gt; root&gt; bin&gt; awk -F: ‘{print 1”\t”1”\t”3}’ /etc/passwd 12345&gt; [root@cetos7 ~]#awk -F: '&#123;print $1" \t"$3&#125;' /etc/passwd&gt; # 以：为分隔符，打印第一列、第三列加上空格和制表符&gt; root 0&gt; bin 1&gt; grep “^UUID” /etc/fstab | awk ‘{print 2,2,4}’ 123456&gt; [root@cetos7 ~]#grep "^UUID" /etc/fstab | awk '&#123;print $2,$4&#125;'&gt; / defaults&gt; /boot defaults&gt; /data defaults&gt; swap defaults&gt; awk变量变量：内置和自定义变量 内置变量 FS：输入字段分隔符，默认为空白字符 awk -v FS=’:’ ‘{print 1,FS,1,FS,3}’ /etc/passwd等同于awk -F: ‘{print 1,”:”,1,”:”,3}’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk -v FS=':' '&#123;print $1,FS,$3&#125;' /etc/passwd&gt; root : 0&gt; bin : 1&gt; OFS：输出字段分隔符，默认为空白字符 awk -v FS=’:’ -v OFS=’:’ ‘{print 1,1,3,$7}’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk -v FS=':' -v OFS=':' '&#123;print $1,$3,$7&#125;' /etc/passwd&gt; root:0:/bin/bash&gt; bin:1:/sbin/nologin&gt; RS：输入记录分隔符，指定输入时的换行符 awk -v RS=’:’ ‘{print }’ /etc/passwd 12345678910111213141516&gt; [root@cetos7 ~]#awk -v RS=':' '&#123;print &#125;' /etc/passwd&gt; root&gt; x&gt; 0&gt; 0&gt; root&gt; /root&gt; /bin/bash&gt; bin&gt; x&gt; 1&gt; 1&gt; bin&gt; /bin&gt; /sbin/nologin&gt; ORS：输出记录分隔符，输出时用指定符号代替换行符 awk -v RS=’:’ -v ORS=’\t’ ‘{print }’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk -v RS=':' -v ORS='\t' '&#123;print &#125;' /etc/passwd &gt; root x 0 0 root /root /bin/bash&gt; bin x 1 1 bin /bin /sbin/nologin&gt; NF：字段数量 awk -F: ‘{print NF}’ /etc/passwd 引用变量时，变量前不需加$ 1234&gt; [root@cetos7 ~]#awk -F: '&#123;print NF&#125;' /etc/passwd&gt; 7&gt; 7&gt; awk -F: ‘{print $(NF-1)}’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk -F: '&#123;print $(NF-1)&#125;' /etc/passwd&gt; /root&gt; /bin&gt; NR：记录号(如果是多个文件，它会一起计数的) awk ‘{print NR}’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk '&#123;print NR&#125;' /etc/passwd&gt; 1&gt; 2&gt; awk END’{print NR}’ /etc/passwd 123&gt; [root@cetos7 ~]#awk END'&#123;print NR&#125;' /etc/passwd &gt; 58&gt; FNR：各文件分别计数,记录号 awk ‘{print FNR}’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk '&#123;print FNR&#125;' /etc/passwd&gt; 1&gt; 2&gt; FILENAME：当前文件名 awk ‘{print FILENAME}’ /etc/fstab 1234&gt; [root@cetos7 ~]#awk '&#123;print FILENAME&#125;' /etc/fstab &gt; /etc/fstab&gt; /etc/fstab&gt; ARGC：命令行参数的个数 awk ‘{print ARGC}’ /etc/fstab /etc/inittab 1234567891011121314&gt; [root@cetos7 ~]#awk '&#123;print ARGC&#125;' /etc/passwd&gt; 2&gt; 2&gt; ``` &gt; 10. ARGV：数组，保存的是命令行所给定的各参数 &gt; &gt;awk '&#123;print ARGV[0]&#125;' /etc/passwd &gt; ```bash&gt; [root@cetos7 ~]#awk '&#123;print ARGV[0]&#125;' /etc/passwd &gt; awk&gt; awk&gt; [root@cetos7 ~]#awk '&#123;print ARGV[1]&#125;' /etc/passwd &gt; /etc/passwd&gt; /etc/passwd&gt; 自定义变量(区分字符大小写) -v var=value 在program中直接定义 示例： awk -v name=”test” ‘{print $1,name}’ /etc/fstab 1234567891011121314&gt; [root@cetos7 ~]#awk -v name="test" '&#123;print $1,name&#125;' /etc/fstab &gt; test&gt; # test&gt; # test&gt; # test&gt; # test&gt; # test&gt; # test&gt; # test&gt; UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920 test&gt; UUID=7d1b5c8d-8054-4496-befe-267963e07605 test&gt; UUID=7556e4a8-128e-457f-99f7-3f1ccf517952 test&gt; UUID=152e9015-e93a-44f9-8c7d-65fe67fb5201 test&gt; awk ‘{sex=”male”;print $1,sex,age;age=”18”}’ /etc/fstab 1234567891011121314&gt; [root@cetos7 ~]#awk '&#123;sex="male";print $1,sex,age;age="18"&#125;' /etc/fstab &gt; male #第一次age变量没有值，为空。所以变量应该先赋值，后使用&gt; # male 18&gt; # male 18&gt; # male 18&gt; # male 18&gt; # male 18&gt; # male 18&gt; # male 18&gt; UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920 male 18&gt; UUID=7d1b5c8d-8054-4496-befe-267963e07605 male 18&gt; UUID=7556e4a8-128e-457f-99f7-3f1ccf517952 male 18&gt; UUID=152e9015-e93a-44f9-8c7d-65fe67fb5201 male 18&gt; 1234567[root@cetos7 ~]#cat awkscript&#123;print script,$1,$2&#125; #print的内容可以写在一个脚本，可以用 -f 调用。[root@cetos7 ~]#awk -F: -f awkscript script="awk" /etc/passwdawk root xawk bin xawk daemon xawk adm x awk的输出命令之二:printf命令格式化输出：printf “FORMAT” , item1, item2, … 必须指定FORMAT 不会自动换行，需要显式给出换行控制符，\n FORMAT中需要分别为后面每个item指定格式符 格式符：与item一一对应 %c：显示字符的ASCII码 %d, %i：显示十进制整数 %e, %E：显示科学计数法数值 %f：显示为浮点数 %g, %G：以科学计数法或浮点形式显示数值 %s：显示字符串 %u：无符号整数 %%：显示%自身 修饰符 #[.#] 第一个数字控制显示的宽度；第二个#表示小数点后精度，%3.1f 左对齐（默认右对齐） %-15s 显示数值的正负符号 %+dprintf示例 示例： awk -F: ‘{printf “%s”,$1}’ /etc/passwd 123456789101112131415161718&gt; [root@cetos7 ~]#awk -F: '&#123;printf "%s",$1&#125;' /etc/passwd &gt; rootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodysystemd-networkdbuspolkitdlibstoragemgmtrpccolordsaslauthabrtsetroubleshootrtkitchronyrpcusernfsnobodyqemuunboundglustertssusbmuxdgeoclueradvdpulsegdmgnome-initial-setupsshdavahipostfixntptcpdumpxiealiceyanglizhaohuappapp2webuserapp3zhanggentoomagetomcatapachememcachedhttpd&gt; ``` &gt; &gt;awk -F: '&#123;printf "%-20s %10d\n",$1,$3&#125;' /etc/passwd &gt; &gt; &gt;awk -F: '&#123;printf "Username: %s,UID:%d\n",$1,$3&#125;' /etc/passwd &gt; ```bash&gt; [root@cetos7 ~]#awk -F: '&#123;printf "Username: %s,UID:%d\n",$1,$3&#125;' /etc/passwd &gt; Username: root,UID:0&gt; Username: bin,UID:1&gt; ``` &gt; &gt;awk -F: '&#123;printf "Username: %15s,UID:%d\n",$1,$3&#125;' /etc/passwd &gt; ```bash&gt; [root@cetos7 ~]#awk -F: '&#123;printf "Username: %15s,UID:%d\n",$1,$3&#125;' /etc/passwd&gt; Username: root,UID:0&gt; Username: bin,UID:1&gt; Username: daemon,UID:2&gt; awk -F: ‘{printf “Username: %-15s,UID:%d\n”,1,1,3}’ /etc/passwd 12345&gt; [root@cetos7 ~]#awk -F: '&#123;printf "Username: %-15s,UID:%d\n",$1,$3&#125;' /etc/passwd&gt; Username: root ,UID:0&gt; Username: bin ,UID:1&gt; Username: daemon ,UID:2&gt; 操作符 算术操作符： x+y, x-y, x*y, x/y, x^y, x%y -x：转换为负数 +x：将字符串转换为数值 字符串操作符：没有符号的操作符，字符串连接 赋值操作符： =, +=, -=, *=, /=, %=, ^=，++, – 下面两语句有何不同 12awk ‘BEGIN&#123;i=0;print ++i,i&#125;’ #先自加再打印awk ‘BEGIN&#123;i=0;print i++,i&#125;’ #先打印再自加 比较操作符： ==, !=, &gt;, &gt;=, &lt;, &lt;= 模式匹配符： ~：左边是否和右边匹配，包含 !~：是否不匹配 示例： awk -F: ‘0 ~ /root/{print0 ~ /root/{print1}’ /etc/passwd 1234&gt; [root@cetos7 ~]#awk -F: '$0 ~ /root/&#123;print $1&#125;' /etc/passwd &gt; root&gt; operator&gt; awk ‘$0~”^root”‘ /etc/passwd 123&gt; [root@cetos7 ~]#awk '$0~"^root"' /etc/passwd &gt; root:x:0:0:root:/root:/bin/bash&gt; awk -F: ‘$3==0’ /etc/passwd 123&gt; [root@cetos7 ~]#awk -F: '$3==0' /etc/passwd &gt; root:x:0:0:root:/root:/bin/bash&gt; 逻辑操作符：与&amp;&amp;，或||，非! 示例： awk -F: ‘3&gt;1000{print3&gt;1000{print1,$3}’ /etc/passwd 123456&gt; [root@cetos7 ~]#awk -F: '$3&gt;1000&#123;print $1,$3&#125;' /etc/passwd&gt; nfsnobody 65534&gt; alice 1003&gt; yang 1004&gt; ·········&gt; awk -F: ‘3&lt;1000{print3&lt;1000{print1,$3}’ /etc/passwd 123456&gt; [root@cetos7 ~]#awk -F: '$3&lt;1000&#123;print $1,$3&#125;' /etc/passwd &gt; root 0&gt; bin 1&gt; daemon 2&gt; ·········&gt; 条件表达式（三目表达式） selector?if-true-expression:if-false-expression 示例： 1[root@cetos7 ~]#awk -F: '&#123;$3&gt;=1000 ? usertype="Common User":usertype="SysUser";printf "%15s:%-s\n",$1,usertype&#125;' /etc/passwd awk PATTERNPATTERN:根据pattern条件，过滤匹配的行，再做处理 如果未指定：空模式，匹配每一行 /regular expression/：仅处理能够模式匹配到的行，需要用/ /括起来 awk ‘/^UUID/{print $1}’ /etc/fstab 123456&gt; [root@cetos7 ~]#awk '/^UUID/&#123;print $1&#125;' /etc/fstab &gt; UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920&gt; UUID=7d1b5c8d-8054-4496-befe-267963e07605&gt; UUID=7556e4a8-128e-457f-99f7-3f1ccf517952&gt; UUID=152e9015-e93a-44f9-8c7d-65fe67fb5201&gt; awk ‘!/^UUID/{print $1}’ /etc/fstab 12345678910&gt; [root@cetos7 ~]#awk '!/^UUID/&#123;print $1&#125;' /etc/fstab &gt; &gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; #&gt; relational expression: 关系表达式，结果为“真”才会被处理 真：结果为非0值，非空字符串 假：结果为空字符串或0值 示例： awk -F: ‘i=1;j=1{print i,j}’ /etc/passwd 123456&gt; [root@cetos7 ~]#awk -F: 'i=1;j=1&#123;print i,j&#125;' /etc/passwd&gt; root:x:0:0:root:/root:/bin/bash&gt; 1 1&gt; bin:x:1:1:bin:/bin:/sbin/nologin&gt; 1 1&gt; awk ‘!0’ /etc/passwd ; awk ‘!1’ /etc/passwd 1234567&gt; [root@cetos7 ~]#awk '!0' /etc/passwd&gt; root:x:0:0:root:/root:/bin/bash&gt; bin:x:1:1:bin:/bin:/sbin/nologin&gt; [root@cetos7 ~]#awk '!1' /etc/passwd&gt; root:x:0:0:root:/root:/bin/bash&gt; bin:x:1:1:bin:/bin:/sbin/nologin&gt; awk -F: ‘NF==”/bin/bash” {printNF==”/bin/bash” {print1,$NF}’ /etc/passwd 1234567891011121314&gt; [root@cetos7 ~]#awk -F: '$NF=="/bin/bash" &#123;print $1,$NF&#125;' /etc/passwd &gt; root /bin/bash&gt; xie /bin/bash&gt; alice /bin/bash&gt; yang /bin/bash&gt; li /bin/bash&gt; zhao /bin/bash&gt; hu /bin/bash&gt; app /bin/bash&gt; app3 /bin/bash&gt; zhang /bin/bash&gt; mage /bin/bash&gt; tomcat /bin/bash&gt; awk -F: ‘NF /bashNF /bash/{print 1,1,NF}’ /etc/passwd 1234567891011121314&gt; [root@cetos7 ~]#awk -F: '$NF ~ /bash$/&#123;print $1,$NF&#125;' /etc/passwd&gt; root /bin/bash&gt; xie /bin/bash&gt; alice /bin/bash&gt; yang /bin/bash&gt; li /bin/bash&gt; zhao /bin/bash&gt; hu /bin/bash&gt; app /bin/bash&gt; app3 /bin/bash&gt; zhang /bin/bash&gt; mage /bin/bash&gt; tomcat /bin/bash&gt; line ranges：行范围 startline,endline：/pat1/,/pat2/ 不支持直接给出数字格式 awk -F: ‘/^root/,/^adm/{print $1}’ /etc/passwd 123456&gt; [root@cetos7 ~]#awk -F: '/^root/,/^adm/&#123;print $1&#125;' /etc/passwd&gt; root&gt; bin&gt; daemon&gt; adm&gt; awk -F: ‘(NR&gt;5&amp;&amp;NR&lt;10){print NR,$1}’ /etc/passwd 123456&gt; [root@cetos7 ~]#awk -F: '(NR&gt;5&amp;&amp;NR&lt;10)&#123;print NR,$1&#125;' /etc/passwd &gt; 6 sync&gt; 7 shutdown&gt; 8 halt&gt; 9 mail&gt; BEGIN/END模式 BEGIN{}：仅在开始处理文件中的文本之前执行一次 END{}：仅在文本处理完成之后执行一次 示例 : awk -F: ‘BEGIN{print “USER USERID”} {print 1”:”1”:”3} END{print “END FILE”}’ /etc/passwd 123456789&gt; [root@cetos7 ~]#awk -F: 'BEGIN&#123;print "USER USERID"&#125; &#123;print $1":"$3&#125; END&#123;print "END FILE"&#125;' /etc/passwd&gt; USER USERID&gt; root:0&gt; bin:1&gt; ······&gt; memcached:986&gt; httpd:80&gt; END FILE&gt; awk -F: ‘{print “USER USERID”;print 1”:”1”:”3} END{print “END FILE”}’ /etc/passwd 123456789101112&gt; [root@cetos7 ~]#awk -F: '&#123;print "USER USERID";print $1":"$3&#125; END&#123;print "END FILE"&#125;' /etc/passwd &gt; USER USERID&gt; root:0&gt; USER USERID&gt; bin:1&gt; ······&gt; USER USERID&gt; memcached:986&gt; USER USERID&gt; httpd:80&gt; END FILE&gt; awk -F: ‘BEGIN{print “USER UID \n————— “}{print 1,1,3}’ /etc/passwd 123456789&gt; [root@cetos7 ~]#awk -F: 'BEGIN&#123;print "USER UID \n--------------- "&#125;&#123;print $1,$3&#125;' /etc/passwd&gt; USER UID &gt; --------------- &gt; root 0&gt; bin 1&gt; ······&gt; memcached:986&gt; httpd:80&gt; awk -F: ‘BEGIN{print “USER UID \n—————– “}{print 1,1,3}END{print”=================”}’ /etc/passwd 12345678910&gt; [root@cetos7 ~]#awk -F: 'BEGIN&#123;print "USER UID \n----------------- "&#125;&#123;print $1,$3&#125;END&#123;print"================="&#125;' /etc/passwd &gt; USER UID &gt; ----------------- &gt; root 0&gt; bin 1&gt; ······&gt; memcached 986&gt; httpd 80&gt; =================&gt; seq 5 | awk ‘i=0’ 123&gt; [root@cetos7 ~]#seq 5 | awk 'i=0'&gt; [root@cetos7 ~]#&gt; seq 5 | awk ‘i=1’ 1234567891011121314&gt; [root@cetos7 ~]#seq 5 | awk 'i=1' &gt; 1&gt; 2&gt; 3&gt; 4&gt; 5&gt; ``` &gt; &gt;seq 5 | awk 'i=!i' &gt; ```bash&gt; [root@cetos7 ~]#seq 5 | awk 'i=!i' &gt; 1&gt; 3&gt; 5&gt; seq 5 | awk ‘{i=!i;print i}’ 1234567&gt; [root@cetos7 ~]#seq 5 | awk '&#123;i=!i;print i&#125;'&gt; 1&gt; 0&gt; 1&gt; 0&gt; 1&gt; seq 5 | awk ‘!(i=!i)’ 1234&gt; [root@cetos7 ~]#seq 5 | awk '!(i=!i)&gt; 2&gt; 4&gt; seq 5 | awk -v i=1 ‘i=!i’ 1234&gt; [root@cetos7 ~]#seq 5 | awk -v i=1 'i=!i'&gt; 2&gt; 4&gt; awk action常用的action分类 Expressions：算术，比较表达式等 Control statements：if, while等 Compound statements：组合语句 input statements output statements：print等 awk控制语句 if-else 语法：if(condition){statement;…}[else statement] if(condition1){statement1}else if(condition2){statement2}else{statement3} 使用场景：对awk取得的整行或某个字段做条件判断 示例： df -h|awk -F% ‘/^\/dev/{print 1}’|awk ‘1}’|awk ‘NF&gt;=10{print 1,1,5}’ 1234&gt; [root@cetos7 ~]#df -h|awk -F% '/^\/dev/&#123;print $1&#125;'|awk '$NF&gt;=10&#123;print $1,$5&#125;' &gt; /dev/sda2 21&gt; /dev/sda1 17&gt; awk ‘BEGIN{ test=100;if(test&gt;90){print “very good”}else if(test&gt;60){ print “good”}else{print “no pass”}}’ 123&gt; [root@cetos7 ~]#awk 'BEGIN&#123; test=100;if(test&gt;90)&#123;print "very good"&#125;else if(test&gt;60)&#123; print "good"&#125;else&#123;print "no pass"&#125;&#125;' &gt; very good&gt; while循环 语法：while(condition){statement;…} 条件“真”，进入循环；条件“假”，退出循环 使用场景： 对一行内的多个字段逐一类似处理时使用 对数组中的各元素逐一处理时使用 示例： awk ‘/^[[:space:]]*linux16/{i=1;while(i&lt;=NF){if(length(i)&gt;=10){printi)&gt;=10){print1,length($i)};i++}}’ /etc/grub2.cfg 123456789&gt; [root@cetos7 ~]#awk '/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF)&#123;if(length($i)&gt;=10)&#123;print $1,length($i)&#125;;i++&#125;&#125;' /etc/grub2.cfg &gt; linux16 30&gt; linux16 46&gt; linux16 16&gt; linux16 16&gt; linux16 50&gt; linux16 46&gt; linux16 16&gt; do-while循环 语法：do {statement;…}while(condition) 意义：无论真假，至少执行一次循环体 示例： awk ‘BEGIN{total=0;i=0;do{ total+=i;i++ } while( i&lt;=100 );print total}’ 123&gt; [root@cetos7 ~]#awk 'BEGIN&#123;total=0;i=0;do&#123; total+=i;i++ &#125; while( i&lt;=100 );print total&#125;'&gt; 5050&gt; for循环 语法：for(expr1;expr2;expr3) {statement;…} 常见用法： for(variable assignment;condition;iteration process) {for-body} 特殊用法：能够遍历数组中的元素 语法：for(var in array) {for-body} 示例： awk ‘/^[[:space:]]*linux16/{for(i=1;i&lt;=NF;i++) {print i,length(i,length(i)}}’ /etc/grub2.cfg 123456789101112131415161718&gt; ^ syntax error&gt; [root@cetos7 ~]#awk '/^[[:space:]]*linux16/&#123;for(i=1;i&lt;=NF;i++) &#123;print $i,length($i)&#125;&#125;' /etc/grub2.cfg&gt; linux16 7&gt; /vmlinuz-3.10.0-862.el7.x86_64 30&gt; root=UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920 46&gt; ro 2&gt; crashkernel=auto 16&gt; rhgb 4&gt; quiet 5&gt; LANG=en_US.UTF-8 16&gt; linux16 7&gt; /vmlinuz-0-rescue-adda87b767b846f69b46c9188469daa7 50&gt; root=UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920 46&gt; ro 2&gt; crashkernel=auto 16&gt; rhgb 4&gt; quiet 5&gt; switch语句 语法：switch(expression) {case VALUE1 or /REGEXP/: statement1; case VALUE2 or /REGEXP2/: statement2; …; default: statementn} break和continue continue:满足条件则结束本次循环，不满足条件，继续执行。 awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i%2==0)continue;sum+=i}print sum}’ 123&gt; [root@cetos7 ~]#awk 'BEGIN&#123;sum=0;for(i=1;i&lt;=100;i++)&#123;if(i%2==0)continue;sum+=i&#125;print sum&#125;' &gt; 2500&gt; break:满足条件则结束整个循环 awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i==50)break;sum+=i}print sum}’ 123&gt; [root@cetos7 ~]#awk 'BEGIN&#123;sum=0;for(i=1;i&lt;=100;i++)&#123;if(i==50)break;sum+=i&#125;print sum&#125;' &gt; 1225&gt; next:提前结束对本行处理而直接进入下一行处理（awk自身循环） awk ‘{if (NR%2==0)next;print NR,$0}’ /etc/fstab 12345678&gt; [root@cetos7 ~]#awk '&#123;if (NR%2==0)next;print NR,$0&#125;' /etc/fstab &gt; 1 &gt; 3 # /etc/fstab&gt; 5 #&gt; 7 # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info&gt; 9 UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920 / xfs defaults 0 0&gt; 11 UUID=7556e4a8-128e-457f-99f7-3f1ccf517952 /data xfs defaults 0&gt; awk数组 关联数组：array[index-expression] index-expression: 可使用任意字符串；字符串要使用双引号括起来如果某数组元素事先不存在，在引用时，awk会自动创建此元素，并将其值初始化为“空串”若要判断数组中是否存在某元素，要使用“index in array” 格式进行遍历 示例： awk ‘BEGIN{weekdays[“mon”]=”Monday”;weekdays[“tue”]=”Tuesday”;print weekdays[“mon”]}’ 1234567891011121314&gt; [root@cetos7 ~]#awk 'BEGIN&#123;weekdays["mon"]="Monday";weekdays["tue"]="Tuesday";print weekdays["mon"]&#125;'&gt; Monday&gt; ``` &gt; 2. 若要遍历数组中的每个元素，要使用for循环 &gt; for(var in array) &#123;for-body&#125; &gt; 注意：var会遍历array的每个索引 &gt; 示例： &gt; awk'BEGIN&#123;weekdays["mon"]="Monday";weekdays["tue"]="Tuesday";for(i in weekdays) &#123;print weekdays[i]&#125;&#125;' &gt; &gt;netstat -tan | awk '/^tcp/&#123;state[$NF]++&#125;END&#123;for(i in state) &#123; print i,state[i]&#125;&#125;'&gt; ```bash&gt; [root@cetos7 ~]#netstat -tan | awk '/^tcp/&#123;state[$NF]++&#125;END&#123;for(i in state) &#123; print i,state[i]&#125;&#125;'&gt; LISTEN 10&gt; ESTABLISHED 1&gt; awk ‘{ip[$1]++}END{for(i in ip) {print i,ip[i]}}’ /var/log/httpd/access_log 123456&gt; [root@cetos7 ~]#awk '&#123;ip[$1]++&#125;END&#123;for(i in ip) &#123;print i,ip[i]&#125;&#125;' /var/log/httpd/access_log &gt; 192.168.189.129 8&gt; 192.168.183.140 8&gt; 192.168.183.1 38&gt; 192.168.189.1 34&gt; awk函数 数值处理： rand()：返回0和1之间一个随机数 awk ‘BEGIN{srand(); for (i=1;i&lt;=5;i++)print int(rand()*100)}’ 1234567&gt; [root@cetos7 ~]#awk 'BEGIN&#123;srand(); for (i=1;i&lt;=5;i++)print int(rand()*100)&#125;' &gt; 87&gt; 77&gt; 39&gt; 61&gt; 76&gt; 字符串处理： length([s])：返回指定字符串的长度 sub(r,s,[t])：对t字符串搜索r表示模式匹配的内容，并将第一个匹配内容替换为s echo “2008:08:08 08:08:08” | awk ‘sub(/:/, “-“, $1)’ 123&gt; [root@cetos7 ~]#echo "2008:08:08 08:08:08" | awk 'sub(/:/,"-",$1)'&gt; 2008-08:08 08:08:08&gt; gsub(r,s,[t])：对t字符串进行搜索r表示的模式匹配的内容，并全部替换为s所表示的内容 echo “2008:08:08 08:08:08” | awk ‘gsub(/:/,”-“,$0)’ 123&gt; [root@cetos7 ~]#echo "2008:08:08 08:08:08" | awk 'gsub(/:/,"-",$0)'&gt; 2008-08-08 08-08-08&gt; • split(s,array,[r])：以r为分隔符，切割字符串s，并将切割后的结果保存至array所表示的数组中，第一个索引值为1,第二个索引值为2,… netstat -tn | awk ‘/^tcp&gt;/{split($5,ip,”:”);count[ip[1]]++}END{for (i in count) {print i,count[i]}}’ 123&gt; [root@cetos7 ~]#netstat -tn | awk '/^tcp\&gt;/&#123;split($5,ip,":");count[ip[1]]++&#125;END&#123;for (i in count) &#123;print i,count[i]&#125;&#125;'&gt; 192.168.183.1 1&gt; 自定义函数格式： 1234function name ( parameter, parameter, ... ) &#123;statementsreturn expression&#125; 示例： 1234567cat fun.awkfunction max(x,y) &#123;x&gt;y?var=x:var=yreturn var&#125;BEGIN&#123;a=3;b=2;print max(a,b)&#125;awk -f fun.awk awk中调用shell命令system命令空格是awk中的字符串连接符，如果system中需要使用awk中的变量可以使用空格分隔，或者说除了awk的变量外其他一律用””引用起来awk ‘BEGIN{system(“hostname”) }’awk ‘BEGIN{score=100; system(“echo your score is “ score)}’ awk脚本将awk程序写成脚本，直接调用或执行示例： 123456789cat f1.awk&#123;if($3&gt;=1000)print $1,$3&#125;awk -F: -f f1.awk /etc/passwdcat f2.awk#!/bin/awk –f#this is a awk script&#123;if($3&gt;=1000)print $1,$3&#125;chmod +x f2.awkf2.awk –F: /etc/passwd 向awk脚本传递参数格式：awkfile var=value var2=value2… Inputfile注意：在BEGIN过程中不可用。直到首行输入完成以后，变量才可用。可以通过-v 参数，让awk在执行BEGIN之前得到变量的值。命令行中每一个指定的变量都需要一个-v参数示例： 12345cat test.awk#!/bin/awk –f&#123;if($3 &gt;=min &amp;&amp; $3&lt;=max)print $1,$3&#125;chmod +x test.awktest.awk -F: min=100 max=200 /etc/passwd 练习 文件ip_list.txt如下格式，请提取” .magedu.com” 前面的主机名部分并写入到回到该文件中 1 blog.magedu.com 2 www.magedu.com … 999 study.magedu.com 1awk -F '[ .]' '&#123;print "."$3"."$4&#125;' ip_list.txt &gt;&gt; ip_list.txt 统计/etc/fstab文件中每个文件系统类型出现的次数 1awk '/^UUID/&#123;filetype[$3]++&#125;END&#123;for (i in filetype)&#123;print i,filetype[i]&#125;&#125;' /etc/fstab 统计/etc/fstab文件中每个单词出现的次数 1awk '&#123;i=1;while(i&lt;=NF)&#123;word[$i]++;i++&#125;&#125;END&#123;for(num in word)&#123;print num,word[num]&#125;&#125;' /etc/fstab 提取出字符串Yd$C@M05MB%9&amp;Bdh7dq+YVixp3vpw中的所有数字 12echo "Yd$C@M05MB%9&amp;Bdh7dq+YVixp3vpw"|awk 'gsub(/[^0-9]/,"",$0)'#把不是数字的全部用空代替掉 有一文件记录了1-100000之间随机的整数共5000个，存储的格式100,50,35,89…请取出其中最大和最小的整数 1awk -F',' '&#123;i=2;max=$1;min=$1;while(i&lt;=NF)&#123;if &#123;$i &gt; max&#125;&#123;max=$i&#125;else if&#123;$i&lt;min&#125;&#123;min=$i&#125;;i++&#125;END&#123;print "max="max,"min="min&#125;' random.txt 解决DOS攻击生产案例：根据web日志或者或者网络连接数，监控当某个IP并发连接数或者短时内PV达到100，即调用防火墙命令封掉对应的IP，监控频率每隔5分钟。防火墙命令为：iptables -A INPUT -s IP -j REJECT 1awk '&#123;access[$1]++&#125;END&#123;for(i in access)&#123;if(access[i]&gt;=100)&#123;print i,access[i]&#125;&#125;&#125;' /var/log/httpd/access_log 将以下文件内容中FQDN取出并根据其进行计数从高到低排序 http://mail.magedu.com/index.html http://www.magedu.com/test.html http://study.magedu.com/index.html http://blog.magedu.com/index.html http://www.magedu.com/images/logo.jpg http://blog.magedu.com/20080102.html 1awk -F '/' '&#123;fqdn[$3]++&#125;END&#123;for (i in fqdn)&#123;print i fqdn[i]&#125;' filename | sort -k2 -nr 将以下文本以inode为标记，对inode相同的counts进行累加，并且统计出同一inode中beginnumber的最小值和endnumber的最大值 inode|beginnumber|endnumber|counts| 106|3363120000|3363129999|10000| 106|3368560000|3368579999|20000| 310|3337000000|3337000100|101| 310|3342950000|3342959999|10000| 310|3362120960|3362120961|2| 311|3313460102|3313469999|9898| 311|3313470000|3313499999|30000| 311|3362120962|3362120963|2| 输出的结果格式为： 310|3337000000|3362120961|10103| 311|3313460102|3362120963|39900| 1awk -F'|' 'NR==1&#123;print;next&#125;&#123;a[$1]?(a[$1]&gt;$2?a[$1]=$2:0):(a[$1]=$2);b[$1]?(b[$1]&lt;$3?b[$1]=$3:0):(b[$1]=$3);c[$1]+=$4&#125;END&#123;l=asorti(a,d);for(i=1;i&lt;=l;i++)print d[i] FS a[d[i]] FS b[d[i]] FS c[d[i]] FS&#125;' f1.txt]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本工具</tag>
        <tag>正则</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密和安全]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[对称加密算法对称加密 加密和解密使用同一个密钥特性： 加密、解密使用同一个密钥，效率高将原始数据分割成固定大小的块，逐个进行加密 缺陷： 密钥过多密钥分发数据来源无法确认 非对称加密算法公钥加密:密钥是成对出现1234[root@cetos7 ~]#cd /etc/ssh[root@cetos7 ssh]#ll-rw-r-----. 1 root ssh_keys 1679 Sep 25 11:01 ssh_host_rsa_key-rw-r--r--. 1 root root 382 Sep 25 11:01 ssh_host_rsa_key.pub 公钥：公开给所有人；public key私钥：自己留存，必须保证其私密性；secret key 特点：用公钥加密数据，只能使用与之配对的私钥解密；反之亦然 功能： 数字签名：主要在于让接收方确认发送方身份对称密钥交换：发送方用对方的公钥加密一个对称密钥后发送给对方数据加密：适合加密较小数据 缺点：密钥长，加密解密效率低下 非对称加密:基于一对公钥/密钥对用密钥对中的一个加密，另一个解密 实现加密： 接收者生成公钥/密钥对：P和S ;公开公钥P，保密密钥S发送者使用接收者的公钥来加密消息M ;将P(M)发送给接收者接收者使用密钥S来解密：M=S(P(M)) 实现数字签名 发送者生成公钥/密钥对：P和S ;公开公钥P，保密密钥S ;使用密钥S来加密消息M ;发送给接收者S(M)接收者使用发送者的公钥来解密M=P(S(M)) 数字签名 结合签名和加密 分离签名 单向散列(数字指纹) 将任意数据缩小成固定大小的“指纹” 任意长度输入固定长度输出若修改数据，指纹也会改变（“不会产生冲突”）无法从指纹中重新生成数据（“单向”） 功能：数据完整性 常见算法 md5: 128bits、 sha1: 160bits、 sha224、sha256、 sha384、 sha512 常用工具 md5sum | sha1sum [ –check ] fileopenssl、 gpgrpm -V 加密类型对比 加密速度 密钥数 分发难度 密钥安全性 对称加密 中 多 难，方式很多，很混乱 安全机制很不健全 单向加密 快 无 最简单，官网公布 不需要安全性 非对称加密 慢 少 中，通过CA分发 有健全的安全机制 密钥交换密钥交换：IKE（ Internet Key Exchange ） 公钥加密DH (Deffie-Hellman)：生成会话密钥， DH A: g,p 协商生成公开的整数g, 大素数pB: g,pA:生成隐私数据 :a (a&lt;p )，计算得出 g^a%p，发送给BB:生成隐私数据 :b,计算得出 g^b%p，发送给AA:计算得出 [(g^b%p)^a] %p = g^ab%p，生成为密钥B:计算得出 [(g^a%p)^b] %p = g^ab%p，生成为密钥 使用gpg实现对称加密 对称加密file文件 12gpg -c filenamels filename.gpg 在另一台主机上解密filename 1gpg -o file -d filename.gpg 使用gpg工具实现公钥加密在hostB主机上用公钥加密，在hostA主机上解密 在hostA主机上生成公钥/私钥对 1gpg –gen-key 在hostA主机上查看公钥 1gpg –list-keys 在hostA主机上导出公钥到/data/magedupubkey 1gpg -a –export -o /data/magedupubkey 从hostA主机上复制公钥文件到需加密的B主机上 1scp magedupubkey hostB: 在需加密数据的hostB主机上生成公钥/私钥对 12gpg –list-keysgpg –gen-key 在hostB主机上导入公钥 12gpg –import magedupubkeygpg –list-keys 用从hostA主机导入的公钥，加密hostB主机的文件file,生成file.gpg 12gpg -e -r magedu f1.txtf1.txt.gpg 复制加密文件到hostA主机 1scp f1.txt.gpg hostA: 在hostA主机解密文件 1gpg -o f1.txt -d f1.txt.gpg 删除公钥和私钥(先删除私钥再删公钥) 12gpg –delete-secret-keys wangegpg –delete-keys wange 中间人攻击 CA和证书PKI: Public Key Infrastructure 签证机构：CA（Certificate Authority）注册机构：RA证书吊销列表：CRL证书存取库： 证书获取证书类型： 证书授权机构的证书服务器用户证书获取证书两种方法： 使用证书授权机构 生成证书请求（csr） 将证书请求csr发送给CA CA签名颁发证书 自签名的证书 自已签发自己的公钥 安全协议SSL功能：机密性，认证，完整性，重放保护两阶段协议，分为握手阶段和应用阶段 握手阶段(协商阶段):客户端和服务器端认证对方身份（依赖于PKI体系，利用数字证书进行身份认证），并协商通信中使用的安全参数、密码套件以及主密钥。 后续通信使用的所有密钥都是通过MasterSecret生成。 应用阶段:在握手阶段完成后进入，在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信 SSL/TLS Handshake协议：包括协商安全参数和密码套件、服务器身份认证（客户端身份认证可选）、密钥交换 ChangeCipherSpec 协议：一条消息表明握手协议已经完成 Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，只是会给出错误警告 Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等 HTTPS 协议：就是“HTTP 协议”和“SSL/TLS 协议”的组合。 HTTP overSSL” 或“HTTP over TLS” ，对http协议的文本数据进行加密处理后，成为二进制形式传输 openssl命令两种运行模式：交互模式和批处理模式openssl version：程序版本号 12[root@cetos7 ~]#openssl versionOpenSSL 1.0.2k-fips 26 Jan 2017 对称加密： 工具：openssl enc, gpg 算法：3des, aes, blowfish, twofish enc命令加密：openssl enc -e -des3 -a -salt -in filename -out filename.enc解密：openssl enc -d -des3 -a -salt –in filename.enc -out filename 单向加密： 工具：md5sum, sha1sum, sha224sum,sha256sum… dgst命令：openssl dgst -md5 [-hex默认] filenamemd5sum filename 生成用户密码 passwd命令: openssl passwd -1 openssl passwd -1 -salt “SALT(最多8位)” 生成随机数 openssl rand -base64|-hex NUM NUM: 表示字节数,使用-hex,每个字符为十六进制,相当于4位二进制,出现的字符数为NUM*2 1234[root@cetos7 ~]#openssl rand -base64 3n5c0[root@cetos7 ~]#openssl rand -hex 3a8e1d2 公钥加密 算法：RSA, ELGamal 工具：gpg, openssl rsautl（man rsautl） 数字签名 算法：RSA, DSA, ELGamal 密钥交换： 算法：dh 生成私钥openssl genrsa -out /PATH/TO/PRIVATEKEY.FILE NUM_BITS 1[root@centos~]#openssl genrsa -out test.key 1024 (umask 077; openssl genrsa –out test.key –des 2048) 加密 1[root@centos~]#(umask 077;openssl genrsa -out test.key -des 2048) openssl rsa -in test.key –out test.bak 将加密key解密 1[root@centos~]#openssl rsa -in test.key -out test.bak 从私钥中提取出公钥 openssl rsa –in test.key –pubout –out test.key.pub 12&gt; [root@centos~]#openssl rsa -in test.key -pubout -out test.key.pub&gt; 随机数生成器：伪随机数字 键盘和鼠标，块设备中断 /dev/random：仅从熵池返回随机数；随机数用尽，阻塞 /dev/urandom：从熵池返回随机数；随机数用尽，会利用软件生成伪随机数,非阻塞OpenSSL 创建CA和申请证书 创建所需要的文件 12touch /etc/pki/CA/index.txt 生成证书索引数据库文件echo 01 &gt; /etc/pki/CA/serial 指定第一个颁发证书的序列号 CA自签证书 生成私钥 12cd /etc/pki/CA/(umask 066; openssl genrsa -out private/cakey.pem 2048) 生成自签名证书 openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 3650 -out /etc/pki/CA/cacert.pem选项说明：-new：生成新证书签署请求-x509：专用于CA生成自签证书-key：生成请求时用到的私钥文件-days n：证书的有效期限-out /PATH/TO/SOMECERTFILE: 证书的保存路径 颁发证书 在需要使用证书的主机生成证书请求 给web服务器生成私钥 ​ (umask 066; openssl genrsa –out /data/test.key 2048) 生成证书申请文件 openssl req -new -key /data/test.key -out /data/test.csr 将证书请求文件传输给CA CA签署证书，并将证书颁发给请求者 openssl ca -in /tmp/test.csr –out /etc/pki/CA/certs/test.crt -days 100注意：默认要求 国家，省，公司名称三项必须和CA一致创建CA和证书管理 查看证书中的信息： openssl x509 -in /PATH/FROM/CERT_FILE -noout -text|issuer|subject|serial|datesopenssl ca -status SERIAL 查看指定编号的证书状态 吊销证书 openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem指定第一个吊销证书的编号,注意：第一次更新证书吊销列表前，才需要执行echo 01 &gt; /etc/pki/CA/crlnumber 更新证书吊销列表 openssl ca -gencrl -out /etc/pki/CA/crl.pem 查看crl文件： openssl crl -in /etc/pki/CA/crl.pem -noout -text SSH(22/tcp) 具体的软件实现： OpenSSH: ssh协议的开源实现，CentOS默认安装dropbear：另一个开源实现 两种方式的用户登录认证： 基于password基于key Openssh软件组成 相关包： openssh openssh-clients openssh-server 工具： 基于C/S结构 Client: ssh, scp, sftp，sloginWindows客户端:xshell, putty, securecrt, sshsecureshellclientServer: sshd ssh客户端 允许实现对远程系统经验证地加密安全访问 当用户远程连接ssh服务器时，会复制ssh服务器/etc/ssh/ssh_host*key.pub（CentOS7默认是ssh_host_ecdsa_key.pub）文件中的公钥到客户机的~./ssh/know_hosts中。下次连接时，会自动匹配相应私钥，不能匹配，将拒绝连接 客户端组件：ssh, 配置文件：/etc/ssh/ssh_configHost PATTERNStrictHostKeyChecking no 首次登录不显示检查提示格式：ssh [user@]host [COMMAND]ssh [-l user] host [COMMAND]常见选项-p port：远程服务器监听的端口-b：指定连接的源IP-v：调试模式-C：压缩方式-X：支持x11转发-t：强制伪tty分配ssh -t remoteserver1 ssh -t remoteserver2 ssh remoteserver3 ssh服务登录验证方式：基于用户和口令登录验证 客户端发起ssh请求，服务器会把自己的公钥发送给用户用户会根据服务器发来的公钥对密码进行加密加密后的信息回传给服务器，服务器用自己的私钥解密，如果密码正确，则用户登录成功 基于密钥的登录方式 首先在客户端生成一对密钥（ssh-keygen）并将客户端的公钥ssh-copy-id 拷贝到服务端当客户端再次发送一个连接请求，包括ip、用户名服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：magedu服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串发送给服务端服务端接受到客户端发来的字符串后，跟之前的字符串进行对比，如果一致，就允许免密码登录 基于key认证 在客户端生成密钥对 ssh-keygen -t rsa [-P ‘’] [-f “~/.ssh/id_rsa”] 把公钥文件传输至远程服务器对应用户的家目录 ssh-copy-id [-i [identity_file]] [user@]host 重设私钥口令： ssh-keygen –p 验证代理（authentication agent）保密解密后的密钥 • 这样口令就只需要输入一次 • 在GNOME中，代理被自动提供给root用户 • 否则运行ssh-agent bash 钥匙通过命令添加给代理 ssh-add rsync命令基于ssh和rsh服务实现高效率的远程系统之间复制文件使用安全的shell连接做为传输方式 rsync -av /etc server1:/tmp 复制目录和目录下文件 12345678910111213141516&gt; [root@CentOS6 data]#ll ssl&gt; total 12&gt; -rw-r--r--. 1 root root 3715 Nov 14 12:27 app.crt&gt; -rw-r--r--. 1 root root 655 Nov 14 08:52 app.csr&gt; -rw-------. 1 root root 887 Nov 14 08:48 app.key&gt; [root@CentOS6 data]#rsync -av /data/ssl 192.168.183.148:/data&gt; root@192.168.183.148's password: &gt; sending incremental file list&gt; ssl/&gt; ssl/app.crt&gt; ssl/app.csr&gt; ssl/app.key&gt; &gt; sent 5472 bytes received 73 bytes 528.10 bytes/sec&gt; total size is 5257 speedup is 0.95&gt; rsync -av /etc/ server1:/tmp 只复制目录下文件 1234567891011&gt; [root@CentOS6 data]#rsync -av /data/ssl/ 192.168.183.148:/data&gt; root@192.168.183.148's password: &gt; sending incremental file list&gt; ./&gt; app.crt&gt; app.csr&gt; app.key&gt; &gt; sent 5460 bytes received 72 bytes 1229.33 bytes/sec&gt; total size is 5257 speedup is 0.95&gt; 比scp更快，只复制不同的文件常用选项：-n 模拟复制过程-v 显示详细过程-r 递归复制目录树-p 保留权限-t 保留时间戳-g 保留组信息-o 保留所有者信息-l 将软链接文件本身进行复制（默认）-L 将软链接文件指向的文件复制-a 存档，相当于–rlptgoD，但不保留ACL（-A）和SELinux属性（-X） pssh工具pssh是一个python编写可以在多台服务器上执行命令的工具，也可实现文件复制选项如下：–version：查看版本-h：主机文件列表，内容格式” [user@]host[:port]”-H：主机字符串，内容格式” [user@]host[:port]”-A：手动输入密码模式-i：每个服务器内部处理信息输出-l：登录使用的用户名-p：并发的线程数【可选】-o：输出的文件目录【可选】-e：错误输入文件【可选】-t：TIMEOUT 超时时间设置，0无限制【可选】-O：SSH的选项-P：打印出服务器返回信息-v：详细模式 pssh示例 通过pssh批量关闭seLinux pssh -H root@192.168.183.158 -i “sed-i “s/SELINUX=enforcing/SELINUX=disabled/“ /etc/selinux/config” 123&gt; [root@cetos7 ~]#pssh -H root@192.168.183.158 -i "sed -i "s/SELINUX=enforcing/SELINUX=disabled/" /etc/selinux/config"&gt; [1] 20:25:13 [SUCCESS] root@192.168.183.158&gt; 批量发送指令 pssh -H root@192.168.1.10 -i setenforce 0pssh -H wang@192.168.1.10 -i hostname 当不支持ssh的key认证时，通过 -A选项，使用密码认证批量执行指令 pssh -H wang@192.168.1.10 -A -i hostname 将标准错误和标准正确重定向都保存至/app目录下 pssh -H 192.168.1.10 -o /app -e /app -i “hostname” SSH端口转发 SSH会自动加密和解密所有SSH客户端与服务端之间的网络数据。但是SSH还能够将其他TCP端口的网络数据通过SSH链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做“隧道”（tunneling),这是因为 SSH 为其他TCP链接提供了一个安全的通道来进行传输而得名。例如Telnet，SMTP，LDAP这些TCP应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果工作环境中的防火墙限制了一些网络端口的使用，但是允许SSH的连接，也能够通过将TCP端口转发来使用SSH进行通讯 SSH 端口转发能够提供两大功能： 加密 SSH Client 端至 SSH Server 端之间的通讯数据突破防火墙的限制完成一些之前无法建立的 TCP 连接SSH端口转发 本地转发： -L localport:remotehost:remotehostport sshserver 选项： -f 后台启用 -N 不打开远程shell，处于等待状态 -g 启用网关功能 示例 1234567891011ssh –L 9527:telnetsrv:23 -Nfg sshsrvtelnet 127.0.0.1 9527 ​``` 当访问本机的9527的端口时，被加密后转发到sshsrv的ssh服务，再解密被转发到telnetsrv:23&gt;data &lt;--&gt; localhost:9527 &lt;--&gt; localhost:XXXXX &lt;--&gt; sshsrv:22 &lt;--&gt; sshsrv:YYYYY &lt;--&gt; telnetsrv:232. 远程转发:-R sshserverport:remotehost:remotehostport sshserver 示例：​```bashssh –R 9527:telnetsrv:23 –Nf sshsrv 让sshsrv侦听9527端口的访问，如有访问，就加密后通过ssh服务转发请求到本机ssh客户端，再由本机解密后转发到telnetsrv:23 Data sshsrv:9527 sshsrv:22 localhost:XXXXX localhost:YYYYY telnetsrv:23 动态端口转发： 当用firefox访问internet时，本机的1080端口做为代理服务器，firefox的访问请求被转发到sshserver上，由sshserver替之访问internet ssh -D 1080 root@sshserver -fNg在本机firefox设置代理socket proxy:127.0.0.1:1080curl –socks5 127.0.0.1:1080 http://www.qq.com X 协议转发 所有图形化应用程序都是X客户程序 能够通过tcp/ip连接远程X服务器数据没有加密机，但是它通过ssh连接隧道安全进行 ssh -X user@remotehost geditremotehost主机上的gedit工具，将会显示在本机的X服务器上传输的数据将通过ssh连接加密 ssh服务器服务器端：sshd 配置文件: /etc/ssh/sshd_config常用参数：PortListenAddress ipLoginGraceTime 2mPermitRootLogin yesStrictModes yes 检查.ssh/文件的所有者，权限等MaxAuthTries 6MaxSessions 10 同一个连接最大会话PubkeyAuthentication yesPermitEmptyPasswords noPasswordAuthentication yesGatewayPorts noClientAliveInterval 单位:秒ClientAliveCountMax 默认3UseDNS yesGSSAPIAuthentication yes 提高速度可改为noMaxStartups 未认证连接最大值，默认值10Banner /path/file 登录提示信息限制可登录用户的办法： AllowUsers user1 user2 user3DenyUsersAllowGroupsDenyGroup sssh服务的最佳实践建议使用非默认端口禁止使用protocol version 1限制可登录用户设定空闲会话超时时长利用防火墙设置ssh访问策略仅监听特定的IP地址基于口令认证时，使用强密码策略 tr -dc A-Za-z0-9_ &lt; /dev/urandom | head -c 12| xargs使用基于密钥的认证禁止使用空密码禁止root用户直接登录限制ssh的访问频度和并发在线数经常分析日志 编译安装dropbearssh协议的另一个实现：dropbear 源码编译安装：12345678910111. 安装开发包组:yum groupinstall "Development tools" 2. 下载dropbear-2017.75.tar.bz2 wget https://matt.ucc.asn.au/dropbear/dropbear-2017.75.tar.bz23. tar xf dropbear-2017.75.tar.bz2 4. cat INSTALL cat README 5. ./configure --prefix=/app/dropbear --sysconfdir=/etc/dropbear6. make PROGRAMS="dropbear dbclient dropbearkey dropbearconvert scp" 7. make PROGRAMS="dropbear dbclient dropbearkey dropbearconvert scp" install 启动ssh服务：12345678910111213141. ls /app/dropbear/sbin/ /app/dropbear/bin/ 2. /app/dropbear/sbin/dropbear -h 3. mkdir /etc/dropbear 4. cd /app/dropbear/binecho 'PATH=$PATH:/app/dropbear/bin:/app/dropbear/sbin' &gt; /etc/profile.d/dropbear.shdropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key 5. cd /app/dropbear/sbindropbear -p :2222 -F –E #前台运行 dropbear -p :2222 #后台运行6. 客户端访问：ssh -p 2222 root@127.0.0.1 或者cd /app/dropbear/bindbclient 127.0.0.1 AIDE 当一个入侵者进入了你的系统并且种植了木马，通常会想办法来隐蔽这个木马（除了木马自身的一些隐蔽特性外,他会尽量给你检查系统的过程设置障碍),通常入侵者会修改一些文件,比如管理员通常用ps -aux来查看系统进程，那么入侵者很可能用自己经过修改的ps程序来替换掉你系统上的ps程序，以使用ps命令查不到正在运行的木马程序。如果入侵者发现管理员正在运行crontab作业,也有可能替换掉crontab程序等等。所以由此可以看出对于系统文件或是关键文件的检查是很必要的.目前就系统完整性检查的工具用的比较多的有两款:Tripwire和AIDE，前者是一款商业软件,后者是一款免费的但功能也很强大的工具. AIDE:高级入侵检测环境)是一个入侵检测工具，主要用途是检查文件的完整性，审计计算机上的那些文件被更改过了. AIDE能够构造一个指定文件的数据库，它使用aide.conf作为其配置文件。 AIDE数据库能够保存文件的各种属性，包括：权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数。 AIDE还能够使用下列算法：sha1、 md5、 rmd160、 tiger，以密文形式建立每个文件的校验码或散列号 这个数据库不应该保存那些经常变动的文件信息，例如：日志文件、邮件、 /proc文件系统、用户起始目录以及临时目录. 安装 yum install aide 修改配置文件 vim /etc/aide.conf (指定对哪些文件进行检测) /test/chameleon R/bin/ps R+a/usr/bin/crontab R+a/etc PERMS!/etc/mtab #“!” 表示忽略这个文件的检查R=p+i+n+u+g+s+m+c+md5权限+索引节点+链接数+用户+组+大小+最后一次修改时间+创建时间+md5校验值NORMAL = R+rmd60+sha256 初始化默认的AIDE的库： aide –init 生成检查数据库（建议初始数据库存放到安全的地方） cd /var/lib/aidemv aide.db.new.gz aide.db.gz 检测： aide –check/-C 更新数据库 aide –update sudo sudo能够授权指定用户在指定主机上运行某些命令。 如果未授权用户尝试使用 sudo，会提示联系管理员 sudo可以提供日志，记录每个用户使用sudo操作 sudo为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权限和使用的主机 sudo使用时间戳文件来完成类似“检票”的系统，默认存活期为5分钟的“入场券” 通过visudo命令编辑配置文件，具有语法检查功能 visudo –c 检查语法visudo -f /etc/sudoers.d/test 配置文件：/etc/sudoers, /etc/sudoers.d/ 时间戳文件：/var/db/sudo 日志文件：/var/log/secure 配置文件支持使用通配符glob ？:任意单一字符 :匹配任意长度字符 [wxc]:匹配其中一个字符[!wxc]:除了这三个字符的其它字符\x : 转义[[alpha]]:字母 示例： /bin/ls [[alpha]]* 配置文件规则有两类1、别名定义:不是必须的2、授权规则:必须的授权规则格式 ：用户 登入主机=(代表用户) 命令示例：root ALL=(ALL) ALL格式说明：user: 运行命令者的身份host: 通过哪些主机(runas)：以哪个用户的身份command: 运行哪些命令 别名 Users和runas: username#uid%group_name%#giduser_alias|runas_alias host: ip或hostnamenetwork(/netmask)host_alias *command: command namedirectorysudoeditCmnd_Alias sudo别名和示例 别名有四种类型：User_Alias, Runas_Alias, Host_Alias ，Cmnd_Alias 别名格式：A-Z* 别名定义： Alias_Type NAME1 = item1, item2, item3 : NAME2 = item4, item5 示例1： Student ALL=(ALL) ALL%wheel ALL=(ALL) ALL 示例2： student ALL=(root) /sbin/pidof,/sbin/ifconfig%wheel ALL=(ALL) NOPASSWD: ALL 示例3 User_Alias NETADMIN= netuser1,netuser2Cmnd_Alias NETCMD = /usr/sbin/ipNETADMIN ALL=（root） NETCMD 示例4 User_Alias SYSADER=wang,mage,%adminsUser_Alias DISKADER=tomHost_Alias SERS=www.magedu.com,172.16.0.0/24Runas_Alias OP=rootCmnd_Alias SYDCMD=/bin/chown,/bin/chmodCmnd_Alias DSKCMD=/sbin/parted,/sbin/fdiskSYSADER SERS= SYDCMD,DSKCMDDISKADER ALL=(OP) DSKCMD 示例5 User_Alias ADMINUSER = adminuser1,adminuser2Cmnd_Alias ADMINCMD = /usr/sbin/useradd，/usr/sbin/usermod,/usr/bin/passwd [a-zA-Z]*, !/usr/bin/passwd rootADMINUSER ALL=(root) NOPASSWD:ADMINCMD，PASSWD:/usr/sbin/userdel 示例6 Defaults:wang runas_default=tomwang ALL=(tom,jerry) ALL 示例7 wang 192.168.1.6,192.168.1.8=(root) /usr/sbin/,!/usr/sbin/useradd 示例8 wang ALL=(ALL) /bin/cat /var/log/messages* sudo命令ls -l /usr/bin/sudosudo –i –u wang 切换身份sudo [-u user] COMMAND -V 显示版本信息等配置信息-u user 默认为root-l,ll 列出用户在主机上可用的和被禁止的命令-v 再延长密码有效期限5分钟,更新时间戳-k 清除时间戳（1970-01-01），下次需要重新输密码-K 与-k类似，还要删除时间戳文件-b 在后台执行指令-p 改变询问密码的提示符号示例：-p “password on %h for user %p:” TCP_Wrappers 工作在第四层（传输层）的TCP协议 对有状态连接的特定服务进行安全检测并实现访问控制 以库文件形式实现 某进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的 判断服务程序是否能够由tcp_wrapper进行访问控制的方法： ldd /PATH/TO/PROGRAM|grep libwrap.sostrings PATH/TO/PROGRAM|grep libwrap.so TCP_Wrappers的使用 配置文件：/etc/hosts.allow, /etc/hosts.deny 检查顺序：hosts.allow，hosts.deny 注意：一旦前面规则匹配，直接生效，将不再继续（默认允许） 基本语法: daemon_list@host: client_list [ :options :option… ] Daemon_list@host格式 单个应用程序的二进制文件名，而非服务名，例如vsftpd 以逗号或空格分隔的应用程序文件名列表，如:sshd,vsftpd ALL表示所有接受tcp_wrapper控制的服务程序 主机有多个IP，可用@hostIP来实现控制 如：in.telnetd@192.168.0.254 客户端Client_list格式 以逗号或空格分隔的客户端列表基于IP地址：192.168.10.1 192.168.1.基于主机名：www.magedu.com .magedu.com 较少用基于网络/掩码：192.168.0.0/255.255.255.0基于net/prefixlen: 192.168.1.0/24（CentOS7）基于网络组（NIS 域）：@mynetwork内置ACL：ALL，LOCAL，KNOWN，UNKNOWN，PARANOIDEXCEPT用法：示例：vsftpd: 172.16. EXCEPT 172.16.100.0/24 EXCEPT 172.16.100.1示例：只允许192.168.1.0/24的主机访问sshd 12345&gt; /etc/hosts.allow &gt; sshd: 192.168.1. &gt; /etc/hosts.deny &gt; sshd :ALL&gt; 示例：只允许192.168.1.0/24的主机访问telnet和vsftpd服务 1234/etc/hosts.allowvsftpd,in.telnetd: 192.168.1./etc/host.deny vsftpd,in.telnetd: ALL [:options]选项： deny 主要用在/etc/hosts.allow定义“拒绝”规则 如：vsftpd: 172.16. :deny allow 主要用在/etc/hosts.deny定义“允许” 规则 如：vsftpd:172.16. :allow spawn 启动一个外部程序完成执行的操作 示例 1sshd: ALL :spawn echo "$(date +%%F) login attempt from %c to %s,%d" &gt;&gt; /var/log/sshd.log 说明：在/etc/hosts.allow中添加，允许登录，并记录日志在/etc/hosts.deny中添加，拒绝登录，并记录日志 %c 客户端信息%s 服务器端信息%d 服务名%p 守护进程的PID%% 表示% twist 实际动作是拒绝访问,使用指定操作替换当前服务,标准输出和ERROR 发送到客户端,默认至/dev/null 12&gt; vsftpd: 172.16. :twist /bin/echo "connection prohibited"&gt; PAM模块 认证库：文本文件，MySQL，NIS，LDAP等 Sun公司于1995 年开发的一种与认证相关的通用框架机制 PAM 是关注如何为服务验证用户的 API，通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开.使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序 一种认证框架，自身不做认证 它提供了对所有服务进行认证的中央机制，适用于本地登录，远程登录，如：telnet,rlogin,fsh,ftp,点对点协议PPP，su等应用程序中，系统管理员通过PAM配置文件来制定不同应用程序的不同认证策略；应用程序开发者通过在服务程序中使用PAM API(pam_xxxx( ))来实现对认证方法的调用；而PAM服务模块的开发者则利用PAM SPI来编写模块（主要调用函数pam_sm_xxxx( )供PAM接口库调用，将不同的认证机制加入到系统中；PAM接口库（libpam）则读取配置文件，将应用程序和相应的PAM服务模块联系起来 PAM架构 PAM相关文件 模块文件目录：/lib64/security/*.so 环境相关的设置：/etc/security/ 123456789101112131415161718[root@cetos7 bin]#cd /lib64/security/[root@cetos7 security]#lspam_access.so pam_gdm.so pam_permit.so pam_time.sopam_cap.so pam_gnome_keyring.so pam_postgresok.so pam_timestamp.sopam_chroot.so pam_group.so pam_pwhistory.so pam_tty_audit.sopam_console.so pam_issue.so pam_pwquality.so pam_umask.sopam_cracklib.so pam_keyinit.so pam_rhosts.so pam_unix_acct.sopam_debug.so pam_lastlog.so pam_rootok.so pam_unix_auth.sopam_deny.so pam_limits.so pam_securetty.so pam_unix_passwd.sopam_echo.so pam_listfile.so pam_selinux_permit.so pam_unix_session.sopam_env.so pam_localuser.so pam_selinux.so pam_unix.sopam_exec.so pam_loginuid.so pam_sepermit.so pam_userdb.sopam_faildelay.so pam_mail.so pam_shells.so pam_warn.sopam_faillock.so pam_mkhomedir.so pam_sss.so pam_wheel.sopam_filter pam_motd.so pam_stress.so pam_xauth.sopam_filter.so pam_namespace.so pam_succeed_if.sopam_fprintd.so pam_nologin.so pam_systemd.sopam_ftp.so pam_oddjob_mkhomedir.so pam_tally2.so 主配置文件:/etc/pam.conf，默认不存在 为每种应用模块提供一个专用的配置文件：/etc/pam.d/APP_NAME 注意：如/etc/pam.d存在，/etc/pam.conf将失效pam认证原理 123456789101112[root@cetos7 security]#cd /etc/pam.d/[root@cetos7 pam.d]#lsatd gdm-launch-environment pluto smartcard-auth system-auth-acchfn gdm-password polkit-1 smartcard-auth-ac systemd-userchsh gdm-pin postlogin smtp vlockconfig-util gdm-smartcard postlogin-ac smtp.postfix vmtoolsdcrond liveinst ppp sshd vsftpdcups login remote su xserverfingerprint-auth other runuser sudofingerprint-auth-ac passwd runuser-l sudo-igdm-autologin password-auth screen su-lgdm-fingerprint password-auth-ac setup system-auth PAM认证原理 PAM认证一般遵循这样的顺序：Service(服务)→PAM(配置文件)→pam_*.so PAM认证首先要确定那一项服务，然后加载相应的PAM的配置文件(位于/etc/pam.d下)，最后调用认证文件(位于/lib/security下)进行安全认证 PAM配置文件详解专用配置文件/etc/pam.d/* 格式type control module-path arguments说明： 模块类型（module-type） Auth 账号的认证和授权Account 与账号管理相关的非认证类的功能，如：用来限制/允许用户对某个服务的访问时间，当前有效的系统资源(最多可以有多少个用户)，限制用户的位置(例如：root用户只能从控制台登录)Password 用户修改密码时密码复杂度检查机制等功能Session 用户获取到服务之前或使用服务完成之后需要进行一些附加的操作，如：记录打开/关闭数据的信息，监视目录等-type 表示因为缺失而不能加载的模块将不记录到系统日志,对于那些不总是安装在系统上的模块有用 Control: PAM库如何处理与该服务相关的PAM模块成功或失败情况 两种方式实现：简单和复杂 简单方式实现：一个关健词实现 required ：一票否决，表示本模块必须返回成功才能通过认证，但是如果该模块返回失败，失败结果也不会立即通知用户，而是要等到同一type中的所有模块全部执行完毕再将失败结果返回给应用程序，即为必要条件requisite ：一票否决，该模块必须返回成功才能通过认证，但是一旦该模块返回失败，将不再执行同一type内的任何模块，而是直接将控制权返回给应用程序。是一个必要条件sufficient ：一票通过，表明本模块返回成功则通过身份认证的要求，不必再执行同一type内的其它模块，但如果本模块返回失败可忽略，即为充分条件optional ：表明本模块是可选的，它的成功与否不会对身份认证起关键作用，其返回值一般被忽略include： 调用其他的配置文件中定义的配置信息 复杂详细实现：使用一个或多个“status=action”[status1=action1 status2=action …]Status:检查结果的返回状态Action:采取行为 ok，done，die，bad，ignore，reset ok 模块通过，继续检查done 模块通过，返回最后结果给应用bad 结果失败，继续检查die 结果失败，返回失败结果给应用ignore 结果忽略，不影响最后结果reset 忽略已经得到的结果PAM认证机制 module-path: 模块路径 相对路径： /lib64/security目录下的模块可使用相对路径 如：pam_shells.so、 pam_limits.so 绝对路径： 模块通过读取配置文件完成用户对系统资源的使用控制 /etc/security/*.conf 1注意：修改PAM配置文件将马上生效 1编辑pam规则时，保持至少打开一个root会话，以防止root身份验证错误 Arguments 用来传递给该模块的参数 PAM模块示例模块：pam_shells功能：检查有效shellman pam_shells示例：不允许使用/bin/csh的用户进行切换 1234567891011121314151617181920[root@cetos7 ~]#vim /etc/pam.d/su auth required pam_shells.so [root@cetos7 pam.d]#cat /etc/shells /bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh#/bin/csh 用#把/bin/csh注释掉[root@cetos7 pam.d]#getent passwd magemage:x:1242:1244::/home/mage:/bin/bash[root@cetos7 pam.d]#usermod -s /bin/csh mage[root@cetos7 pam.d]#getent passwd mage mage:x:1242:1244::/home/mage:/bin/csh 把账号xie的shell类型改成 /bin/csh[root@cetos7 pam.d]#su - magePassword: su: Authentication failure mage账号将不可切换，其它不受影响 tail /var/log/secure 模块：pam_securetty.so功能：只允许root用户在/etc/securetty列出的安全终端上登陆示例：允许root在telnet登陆 1234[root@centos7 ~]vim /etc/pam.d/remote #auth required pam_securetty.so #将这一行加上注释 或者/etc/securetty文件中加入 pts/0,pts/1…pts/n 模块：pam_nologin.so功能： 如果/etc/nologin文件存在,将导致非root用户不能登陆 如果用户shell是/sbin/nologin 时，当该用户登陆时，会显示/etc/nologin文件内容，并拒绝登陆 模块：pam_limits.so功能：在用户级别实现对其可使用的资源的限制，例如：可打开的文件数量，可运行的进程数量，可用内存空间修改限制的实现方式： ulimit命令，立即生效，但无法保存 -n 每个进程最多的打开的文件描述符个数-u 最大用户进程数-S 使用 soft（软）资源限制-H 使用 hard（硬）资源限制 配置文件：/etc/security/limits.conf, /etc/security/limits.d/*.conf 配置文件：每行一个定义 1&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt; \ 应用于哪些对象 Username 单个用户@group 组内所有用户* 所有用户 \ 限制的类型 Soft 软限制,普通用户自己可以修改Hard 硬限制,由root用户设定，且通过kernel强制生效- 二者同时限定 \ 限制的资源 nofile 所能够同时打开的最大文件数量,默认为1024nproc 所能够同时运行的进程的最大数量,默认为1024 \ 指定具体值 限制用户最多打开的文件数和运行进程数 1234567&gt; &gt; /etc/pam.d/system-auth &gt; &gt; session required pam_limits.so &gt; &gt; &gt; &gt; vim /etc/security/limits.conf &gt; &gt; apache – nofile 10240 用户apache可打开10240个文件 &gt; &gt; student hard nproc 20 用户student不能运行超过20个进程&gt; &gt;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>加密</tag>
        <tag>openssl</tag>
        <tag>ssh</tag>
        <tag>CA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS服务]]></title>
    <url>%2F2019%2F01%2F03%2FDNS%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;DNS(DomainName Server)是域名解析服务器，提供域名和IP地址之间一种转换机制，IP地址是平面结构不容易记住，DNS是层次化的结构，便于记忆 DNS域名 根域：根域位于层次结构的最顶部并用“.”来表示，全球有十三个根服务器，一个主根服务器，十二个辅助根服务器。 顶级域:顶级域是按照组织或地理位置来划分的 .gov：表示政府组织.com：表示商业组织.net：网络中心.org：非营利性组织.edu：教育部门 .cn .uk .us：国家国别的代码，cn表示中国，uk表示英国，us表示美国 二级域：由国际域名组织为互联网中的个人或部门指定和登记的二级域，如51cto.com,baidu.com DNS服务器类型 主DNS服务器(Master DNS）:管理和维护所负责解析的域内解析库的服务器 辅助DNS服务器 (SlaveDNS)：从主服务器或从服务器“复制”（区域传输）解析库副本 序列号：解析库版本号，主服务器解析库变化时，其序列递增刷新时间间隔：从服务器从主服务器请求同步解析的时间间隔重试时间间隔：从服务器请求同步失败时，再次尝试时间间隔过期时长：从服务器联系不到主服务器时，多久后停止服务 缓存DNS服务器:没有自己的区域数据文件，只是帮助客户端向外部DNS请求查询，然后将查询的结果保存到它的缓存中。 “通知”机制：主服务器解析库发生变化时，会主动通知从服务器 一个域可以有拥有多个从服务器，但只能有一台主服务器一台从服务器也可以从另一台从服务器那里获取数据客户端检索本地数据文件的相关记录，客户端将无法自行解释的需求，通过53端口送给指定的DNS服务器 DNS解析DNS查询类型递归查询迭代查询 名称服务器：域内负责解析本域内的名称的主机根服务器：13组服务器 解析类型FQDN(Fully Qualified Domain Name)完全合格域名，由主机名+域名组成，如www.51cto.com 正向解析：FQDN–&gt;IP,把完全合格域名解析为IP地址反向解析：IP–&gt;FQDN，把IP解析为完全合格域名。 注意：正反向解析是两个不同的名称空间，是两棵不同的解析树 解析答案肯定答案：否定答案：请求的条目不存在等原因导致无法返回结果权威答案：非权威答案 BIND&ensp;&ensp;&ensp;&ensp;BIND是BerkeleyInternet Name Daemon的缩写,BIND是在Internet上应用最为广泛的DNS服务器，提供稳定与可信赖的下层结构以提供域名与IP地址的转换 Bind的相关软件包bind-9.8.2-0.17.rc1.el6.x86_64提供域名服务的主程序和相关文件bind-libs-9.8.2-0.17.rc1.el6.x86_64提供域名域名服务器所依赖的库文件bind-utils-9.8.2-0.17.rc1.el6.x86_64提供了对DNS 服务的测试工具程序 注：bind-chroot：安装上这个包之后让named进程有限的活动在/var/named/chroot/中防止黑客攻击导致服务器的崩溃。这里就不安装了，因为安装之后除了路径改变之后其他均不变。所以为了更好的熟悉过程就暂时不装了 直接用yum安装yum install bind -y bind服务器服务脚本和名称：/etc/rc.d/init.d/named /usr/lib/systemd/system/named.service主配置文件：/etc/named.conf, /etc/named.rfc1912.zones, /etc/rndc.key解析库文件：/var/named/ZONE_NAME.ZONE注意： 一台物理服务器可同时为多个区域提供解析 必须要有根区域文件；named.ca 应该有两个（如果包括ipv6的，应该更多）实现localhost和本地回环地址的解析库 资源记录资源记录定义的格式语法：name [TTL] IN rr_type value注意： TTL可从全局继承 @可用于引用当前区域的名字 同一个名字可以通过多条记录定义多个不同的值；此时DNS服务器会以轮询方式响应 同一个值也可能有多个不同的定义名字；通过多个不同的名字指向同一个值进行 定义；此仅表示通过多个不同的名字可以找到同一个主机 区域解析库：由众多RR组成 资源记录：Resource Record, RR记录类型：A, AAAA, PTR, SOA, NS, CNAME, MX A：internet Address，作用，FQDN –&gt; IPAAAA：FQDN –&gt; IPv6PTR：PoinTeR，IP –&gt; FQDNSOA：Start Of Authority，起始授权记录；一个区域解析库有且仅能有一个SOA记录，必须位于解析库的第一条记录NS：Name Server，专用于标明当前区域的DNS服务器CNAME ： Canonical Name，别名记录MX：Mail eXchanger，邮件交换器 SQA name: 当前区域的名字，例如”magedu.com.”value: 有多部分组成 当前区域的主DNS服务器的FQDN，也可以使用当前区域的名字；当前区域管理员的邮箱地址；但地址中不能使用@符号，一般用.替换例：admin.magedu.com.主从服务区域传输相关定义以及否定的答案的统一的TTL 1234567$TTL 1D@ IN SOA @ rname.invalid. ( 0 ; serial 序列号 1D ; refresh 刷新时间 1H ; retry 重试时间 1W ; expire 过期时间 3H ) ; minimum 否定答案的TTL值 NS记录 name: 当前区域的名字 value: 当前区域的某DNS服务器的名字，例如ns.magedu.com. 注意：一个区域可以有多个NS记录例如： 12magedu.com. IN NS ns1.magedu.com. magedu.com. IN NS ns2.magedu.com. 注意:(1) 相邻的两个资源记录的name相同时，后续的可省略(2) 对NS记录而言，任何一个ns记录后面的服务器名字，都应该在后续有一个A记录 MX记录name: 当前区域的名字value: 当前区域的某邮件服务器(smtp服务器)的主机名一个区域内，MX记录可有多个；但每个记录的value之前应该有一个数字(0-99)，表示此服务器的优先级；数字越小优先级越高12magedu.com. IN MX 10 mx1.magedu.com. IN MX 20 mx2.magedu.com. 注意：对MX记录而言，任何一个MX记录后面的服务器名字，都应该在后续有一个A记录 A记录1name: 某主机的FQDNvalue: 主机名对应主机的IP地址例如：1234567www.magedu.com. IN A 1.1.1.1 www.magedu.com. IN A 2.2.2.2 mx1.magedu.com. IN A 3.3.3.3 mx2.magedu.com. IN A 4.4.4.4 $GENERATE 1-254 HOST$ A 1.2.3.$ *.magedu.com. IN A 5.5.5.5 magedu.com. IN A 6.6.6.6 避免用户写错名称时给错误答案，可通过泛域名解析进行解析至某特定地址 其它记录 AAAA:name: FQDNvalue: IPv6 PTR:name: IP，有特定格式，把IP地址反过来写，1.2.3.4，要写作4.3.2.1；而有特定后缀: in-addr.arpa.，所以完整写法为：124.3.2.1.in-addr.arpa.value: FQDN 14.3.2.1.in-addr.arpa. IN PTR www.magedu.com. 别名记录CNAME：name: 别名的FQDNvalue: 真正名字的FQDN例如：1www.magedu.com. IN CNAME websrv.magedu.com. 子域授权：每个域的名称服务器，都是通过其上级名称服务器在解析库进行授权 类似根域授权tld： 1234.com. IN NS ns1.com..com. IN NS ns2.com.ns1.com. IN A 2.2.2.1ns2.com. IN A 2.2.2.2 magedu.com. 在.com的名称服务器上，解析库中添加资源记录 123456magedu.com. IN NS ns1.magedu.com.magedu.com. IN NS ns2.magedu.com.magedu.com. IN NS ns3.magedu.com.ns1.magedu.com. IN A 3.3.3.1ns2.magedu.com. IN A 3.3.3.2ns3.magedu.com. IN A 3.3.3.3 glue record：粘合记录，父域授权子域的记录 DNS实验 正向的主DNS服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[root@CentOS6 ~]#vim /etc/sysconfig/network-scripts/ifcfg-eth0 BOOTPROTO=staticIPADDR=192.168.183.158PREFIX=24DNS1=192.168.183.148 [root@CentOS6 ~]#service network restartShutting down interface eth0: Device state: 3 (disconnected) [ OK ]Shutting down loopback interface: [ OK ]Bringing up loopback interface: [ OK ]Bringing up interface eth0: Active connection state: activatedActive connection path: /org/freedesktop/NetworkManager/ActiveConnection/2 [ OK ][root@CentOS6 ~]#cat /etc/resolv.conf# Generated by NetworkManagerdomain localdomainsearch localdomainnameserver 192.168.183.148[root@CentOS6 ~]#ping 114.114.114.114 PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.64 bytes from 114.114.114.114: icmp_seq=1 ttl=128 time=14.7 ms64 bytes from 114.114.114.114: icmp_seq=2 ttl=128 time=13.8 ms[root@CentOS6 ~]#ping www.baidu.com ping: unknown host www.baidu.com我们需要把192.168.183.148这个DNS服务器配置文件修改下[root@centos7 ~]#vim /etc/named.conf// listen-on port 53 &#123; localhost; &#125;;......省略.......// allow-query &#123; localhost; &#125;; allow-transfer &#123;192.169.183.136;&#125;; 为后面搭建主备服务器准备的把这两行注释掉[root@centos7 ~]#named-checkconf 检查语法是否有错误[root@centos7 ~]#rndc reload 修改文件生效server reload successful[root@CentOS6 ~]#dig www.magedu.com; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; www.magedu.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 55470;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 16;; QUESTION SECTION:;www.magedu.com. IN A;; ANSWER SECTION:www.magedu.com. 600 IN A 101.200.188.230......省略.......[root@centos7 ~]#vim /etc/named.rfc1912.zones ......省略.......zone "localhost.localdomain" IN &#123; type master; file "named.localhost"; allow-update &#123; none; &#125;;&#125;;zone "mmagedu.com" IN &#123; type master; file "magedu.com.zone"; &#125;;......省略.......[root@centos7 ~]#cd /var/named/[root@centos7 named]#cp -a named.localhost magedu.com.zone cp时要注意文件的属性[root@centos7 named]#lltotal 20drwxrwx--- 2 named named 23 Nov 24 14:19 datadrwxrwx--- 2 named named 60 Nov 24 14:20 dynamic-rw-r----- 1 root named 152 Jun 21 2007 magedu.com.zone-rw-r----- 1 root named 2281 May 22 2017 named.ca-rw-r----- 1 root named 152 Dec 15 2009 named.empty-rw-r----- 1 root named 152 Jun 21 2007 named.localhost-rw-r----- 1 root named 168 Dec 15 2009 named.loopbackdrwxrwx--- 2 named named 6 Apr 13 2018 slaves[root@centos7 named]#vim magedu.com.zone $TTL 1D@ IN SOA dns1 admin.magedu.com. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns1dns1 A 192.168.183.148 www CNAME websrvwebsrv A 6.6.6.6websrv A 7.7.7.7websrv A 8.8.8.8@ A 6.6.6.6 泛域名解析* A 6.6.6.6[root@centos7 named]#rndc reloadserver reload successful[root@CentOS6 ~]#dig www.magedu.com; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; www.magedu.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 20887;; flags: qr aa rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 1, ADDITIONAL: 1;; QUESTION SECTION:;www.magedu.com. IN A;; ANSWER SECTION:www.magedu.com. 86400 IN CNAME websrv.magedu.com.websrv.magedu.com. 86400 IN A 6.6.6.6websrv.magedu.com. 86400 IN A 7.7.7.7websrv.magedu.com. 86400 IN A 8.8.8.8 反向的主DNS服务器 123456789101112131415161718192021222324252627282930313233343536373839404142[root@centos7 ~]#vim /etc/named.rfc1912.zoneszone "183.168.192.in-addr.arpa" &#123; type master; file "192.168.183.158.zone";&#125;;[root@centos7 ~]#cd /var/named/[root@centos7 named]#vim 192.168.183.zone$TTL 86400@ IN SOA dnsserver admin.magedu.com. ( 20181124; 3H; 10M; 1D; 1H); NS dnsserverdnsserver A 192.168.183.148148 PTR dnsserver.magedu.com.100 PTR www.magedu.com.120 PTR blog.magedu.com&lt;92.168.183.zone" 12L, 227C written[root@centos7 named]#named-checkconf[root@centos7 named]#named-checkzone 183.168.192.in-addr.arpa 192.168.183.zonezone 183.168.192.in-addr.arpa/IN: loaded serial 20181124OK[root@centos7 named]#rndc reloadserver reload successful[root@CentOS6 ~]#dig -x 192.168.183.148; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; -x 192.168.183.148;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 53616;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1;; QUESTION SECTION:;148.183.168.192.in-addr.arpa. IN PTR;; ANSWER SECTION:148.183.168.192.in-addr.arpa. 86400 IN PTR dnsserver.magedu.com.......省略....... DNS冗错(DNS主备服务器的搭建)再找一台主机(192.168.183.137)搭建DNS服务器安装bind yum install bind -y修改配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[root@centos7 ~]#vim /etc/named.conf......省略.......// listen-on port 53 &#123; 127.0.0.1; &#125;; //注释掉 listen-on-v6 port 53 &#123; ::1; &#125;; directory "/var/named"; dump-file "/var/named/data/cache_dump.db"; statistics-file "/var/named/data/named_stats.txt"; memstatistics-file "/var/named/data/named_mem_stats.txt";// allow-query &#123; localhost; &#125;; //注释掉 allow-transfer &#123; none;&#125;;......省略.......[root@centos7 ~]# vim /etc/named.rfc1912.zoneszone "magedu.com" &#123; type slave; master &#123;192.168.183.148;&#125;; file "slaves/magedu.com.zone.slave";&#125;;[root@centos7 ~]#vim /var/named/magedu.com.zone //主服务器 NS dns1 NS dns2dns1 A 192.168.183.148dns2 A 192.168.183.137 [root@centos7 ~]#rndc reloadserver reload successful[root@centos7 ~]# systemctl start named[root@centos7 ~]# cd /var/named/slaves/[root@centos7 slaves]# lltotal 4-rw-r--r--. 1 named named 524 Nov 24 21:20 magedu.com.zone.slave[root@CentOS6 ~]#dig www.magedu.com ; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; www.magedu.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 33539;; flags: qr aa rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 3, ADDITIONAL: 3;; QUESTION SECTION:;www.magedu.com. IN A;; ANSWER SECTION:www.magedu.com. 86400 IN CNAME websrv.magedu.com.websrv.magedu.com. 86400 IN A 6.6.6.6websrv.magedu.com. 86400 IN A 7.7.7.7websrv.magedu.com. 86400 IN A 8.8.8.8;; AUTHORITY SECTION:magedu.com. 86400 IN NS dns1.magedu.com.magedu.com. 86400 IN NS dns2.magedu.com.;; ADDITIONAL SECTION:dns1.magedu.com. 86400 IN A 192.168.183.148dns2.magedu.com. 86400 IN A 192.168.183.137;; Query time: 6 msec;; SERVER: 192.168.183.148#53(192.168.183.148) 主服务器;; WHEN: Sat Nov 24 20:43:12 2018;; MSG SIZE rcvd: 206把主服务器网线掐断[root@CentOS6 ~]#dig www.magedu.com; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.68.rc1.el6 &lt;&lt;&gt;&gt; www.magedu.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 55691;; flags: qr aa rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 3, ADDITIONAL: 3;; QUESTION SECTION:;www.magedu.com. IN A;; ANSWER SECTION:www.magedu.com. 86400 IN CNAME websrv.magedu.com.websrv.magedu.com. 86400 IN A 7.7.7.7websrv.magedu.com. 86400 IN A 8.8.8.8websrv.magedu.com. 86400 IN A 6.6.6.6;; AUTHORITY SECTION:magedu.com. 86400 IN NS dns2.magedu.com.magedu.com. 86400 IN NS dns1.magedu.com.;; ADDITIONAL SECTION:dns1.magedu.com. 86400 IN A 192.168.183.148dns2.magedu.com. 86400 IN A 192.168.183.137;; Query time: 5 msec;; SERVER: 192.168.183.136#53(192.168.183.137) 备用服务器;; WHEN: Sat Nov 24 20:48:16 2018;; MSG SIZE rcvd: 206]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>dns</tag>
        <tag>解析</tag>
        <tag>资源记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNCP服务]]></title>
    <url>%2F2019%2F01%2F03%2FDHCP%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[网络配置&ensp;&ensp;&ensp;&ensp;DHCP前身是BOOTP，在Linux的网卡配置中也能看到显示的BOOTP，DHCP引进一个bootp没有的概念：租约。bootp分配的地址是永久的，而dhcp分配的地址是可以有期限的。12[root@CentOS6 ~]#grep -i bootproto /etc/sysconfig/network-scripts/ifcfg-eth0 BOOTPROTO=dhcp DHCP可以自动分配IP、子网掩码、网关、DNS。 DHCP客户端使用的端口68，服务端使用端口67，使用的UDP应用层的协议。 &ensp;&ensp;&ensp;&ensp;DHCP一般不为服务器分配IP，因为他们要使用固定IP，所以DHCP一般只为办公环境的主机分配IP。服务器一旦开机则自动分配IP，并有一定的租期，租期到了则收回，IP可以续租，续租失败则收回并重新分配，如果服务器关闭则收回IP，先到先得的原则，哪台主机先申请就优先分配，并且基于广播机制(DHCP服务器和客户端需要在一个局域网).但DHCP也可以为其他网段内主机分配IP，只要连接两个网段中间的路由器能转发DHCP配置请求即可，但这要求路由器配置中继功能。 续租&ensp;&ensp;&ensp;&ensp;50%：租赁时间达到50%时来续租，刚向DHCP服务器发向新的DHCPREQUEST请求。如果dhcp服务没有拒绝的理由，则回应DHCPACK信息。当DHCP客户端收到该应答信息后，就重新开始新的租用周期&ensp;&ensp;&ensp;&ensp;87.5%：如果之前DHCP Server没有回应续租请求，等到租约期的7/8时，主机会再发送一次广播请求 主要用途用于内部网络和网络服务供应商自动分配IP地址给用户用于内部网络管理员作为对所有电脑作集中管理的手段 使用场景自动化安装系统解决IPV4资源不足问题DHCP服务 DHCP的工作原理(前四种经常用到) DHCP DISCOVER：客户端到服务器，客户端设置为自动获取后一开机就会向网络发广播 DHCP OFFER ：服务器到客户端，如果网络中有DHCP服务器就会分配一个IP并同时在网络中进行标记此IP已被占用 DHCP REQUEST：客户端到服务器，网络中有多个DHCP同时分配IP，客户端这时就会选择一个最快到达的ip DHCP ACK ：服务器到客户端，服务器最终确认 DHCP NAK：服务器到客户端,通知用户无法分配合适的IP地址 DHCP DECLINE ：客户端到服务器，指示地址已被使用 DHCP RELEASE：客户端到服务器，放弃网络地址和取消剩余的租约时间 DHCP INFORM：客户端到服务器, 客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，极少用到 模拟dhcp的实现过程 准备：两台虚拟机（centos7模拟DHCP服务器，centos6模拟客户端）centos7本身使用静态获取，centos6为动态获取 并且为仅主机模式关闭防火墙 iptables -vnL清空防火墙 iptables -F关闭SELinux 检查状态getenforcevim /etc/sysconfig/selinux 改为SELinux=disabled 重启后生效对centos7设置，使其成为dhcp服务器 打开虚拟机—&gt;编辑—-&gt;虚拟网络设置—&gt;选中仅主机—&gt;取消下面DHCP设置 取消DHCP服务就意味着网络中没有了DHCP服务器，那么客户端如果设置DHCP获取那么是不能获取到IP 在客户机将其获取方式改为DHCP vim /etc/sysconfig/network-scripts/ifcfg-eth0 设置完之后重启，客户机将不能获取IP，因为网络中没有DHCP服务器 开始配置DHCP服务器（centos7）配置前首先安装包 12[root@cetos7 ~]#yum install dhcp -yLoaded plugins: fastestmirror, langpacks 在其他的服务安装后就可以开启服务，但dhcp比较特殊，所以此时应先复制模板到配置文件进行相关设置，然后再开启服务 如果此时开启服务肯定是失败的12[root@cetos7 ~]#systemctl start httpdFailed to start httpd.service: Unit not found. 复制模板12[root@cetos7 ~]#cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.confcp: overwrite '/etc/dhcp/dhcpd.conf'? y 配置文件123456789101112[root@cetos7 ~]#vim /etc/dhcp/dhcpd.conf# No service will be given on this subnet, but declaring it helps the # DHCP server to understand the network topology.subnet 192.168.183.0 netmask 255.255.255.0 &#123; #添加网断及子网掩码 range 192.168.183.10 192.168.183.100; #指定ip范围 &#125;# This is a very basic subnet declaration.subnet 10.254.239.0 netmask 255.255.255.224 &#123; range 10.254.239.10 10.254.239.20; 重启服务1[root@centos ~]#systemctl restart dhcpd 重启完之后再次重启客户端(centos6),然后通过ifcongfig就能看见客户端获取到你指定范围内的ip了。至此已经实现一个模拟的DHCP服务器。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>dhcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible基础及常用模块]]></title>
    <url>%2F2019%2F01%2F03%2FAnsible%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Ansible的概念&ensp;&ensp;&ensp;&ensp;概念：是一个配置管理工具，是一个自动化运维工具，通过ssh实现配置管理、应用部署、任务执行等功能。要实现ansible，必须基于key验证作用：可以完成一些批量任务或者完成一些需要经常重复的工作 同时在100台服务器上安装服务，并在安装后启动服务将某个文件一次性拷贝到100台服务器上每当有新服务器加入工作环境时都要部署新的服务，也就是需要经常重复完成相同的工作 此时都可以用到ansible在复制文件到受控主机时，受控主机目录下有此文件则ansible不做任何处理，若没有则复制，这些功能是shell所不具备的 控制其他主机的主机叫主控端被控制的主机叫被控端 ansible 中小型企业500台主机左右saltstack 大型企业puppet 超大型企业 Ansible的配置文件使用ansible前必须做到：1、在主控机上安装ansible基于epel源1yum install ansible -y 2、在ansible配置文件中将受控主机写入”管理清单（/etc/ansible/hosts）”。 方式有两种： 文件配置如果安装后没有配置文件直接使用ansible则会出现如下提示：1234567891011121314151617181920212223[root@CentOS7 ~]#ansible 192.168.183.158 -m ping[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicitlocalhost does not match 'all'[WARNING]: Could not match supplied host pattern, ignoring: 192.168.183.148将受控主机的IP写入配置文件/etc/ansible/hosts的最底部如下：# Here's another example of host ranges, this time there are no# leading 0s:## db-[99:101]-node.example.com192.168.183.158 192.168.183.132[root@CentOS7 ~]#ansible 192.168.183.158,192.168.183.132 -m ping192.168.183.132 | UNREACHABLE! =&gt; &#123; "changed": false, "msg": "Failed to connect to the host via ssh: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).\r\n", "unreachable": true&#125;192.168.183.158 | UNREACHABLE! =&gt; &#123; "changed": false, "msg": "Failed to connect to the host via ssh: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).\r\n", "unreachable": true&#125; 因为ansible是基于ssh的，所以要把受控主机的相关信息也要写全如下12345678910111213## db-[99:101]-node.example.com192.168.183.148 ansible_port=22 ansible_user=root ansible_ssh_pass=123456192.168.183.132 ansible_port=22 ansible_user=root ansible_ssh_pass=123456 "/etc/ansible/hosts" 47L, 1165C written [root@CentOS6 ~]#ansible 192.168.183.148,192.168.183.132 -m ping 192.168.183.148 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;192.168.183.132 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 如果受控主机较多这样配置显然是不可取的，大多数情况下都使用第二种方法基于秘钥认证基于秘钥认证(由于前文写过，这里简单描述下)首先执行ssh-kengen生成秘钥对将生成的秘钥发送给受控机 ssh-copy-id 192.168.183.158123456789[root@centos7 data]#ansible all -m ping 192.168.183.132 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;192.168.183.158 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 小结：在使用ansible时首先要安装包，然后将受控主机的IP写入配置文件/etc/ansible/hosts中，使用秘钥验证方式则首先要生成秘钥对ssh-keygen将生成的秘钥发送至受控主机ssh-copy-id IP ansible命令执行ansible命令执行过程加载自己的配置文件 默认/etc/ansible/ansible.cfg加载自己对应的模块文件，如command通过ansible将模块或命令生成对应的临时py文件，并将该 文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件给文件+x执行执行并返回结果删除临时py文件，sleep 0退出 执行状态：绿色：执行成功并且不需要做改变的操作黄色：执行成功并且对目标主机做变更红色：执行失败 ansible的Host-patternansible [-m module_name] [-a args]–version 显示版本ansible –version-v 详细过程 –vv -vvv更详细–list-hosts 显示主机列表，可简写 –list ansible all –list-hosts-u, –user=REMOTE_USER 执行远程执行的用户-k, –ask-pass 提示输入ssh连接密码，默认Key验证-K, –ask-become-pass 提示输入sudo时的口令 1234[root@centos7 ~]#ansible 192.168.183.158 -m ping -u xie -kSSH password:[root@centos7 ~]#ansible 192.168.183.158 -m ping -u xie -KSUDO password: -C, –check 检查，并不执行-T, –timeout=TIMEOUT 执行命令的超时时间，默认10s-b, –become 代替旧版的sudo 切换–become-user=USERNAME 指定sudo的runas用户，默认为root ansible all -m ping -u wang -k -b –become-user=mage All ：表示所有Inventory中的所有主机 ansible all –m ping * : 通配符 ansible “*” -m ping 或关系 ansible websrvs:appsrvs -m ping 逻辑与 ansible ‘websrvs:&amp;dbsrvs’ –m ping 在websrvs组并且在dbsrvs组中的主机 逻辑非 ansible ‘websrvs:!dbsrvs’ –m ping 在websrvs组，但不在dbsrvs组中的主机注意：此处为单引号 综合逻辑 ansible ‘websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs’ –m ping 正则表达式 ansible ‘~(web|db).*.magedu.com’ –m ping 注：列表清单中最好都使用单引号 Ansible相关文件配置文件/etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性/etc/ansible/hosts 主机清单/etc/ansible/roles/ 存放角色的目录 程序/usr/bin/ansible 主程序，临时命令执行工具/usr/bin/ansible-doc 查看配置文档，模块功能查看工具/usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台/usr/bin/ansible-playbook 定制自动化任务，编排剧本工具/usr/bin/ansiblepull 远程执行命令的工具/usr/bin/ansible-vault 文件加密工具/usr/bin/ansible-console 基于Console界面与用户交互的执行工具 Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）12345678910111213[defaults]#inventory = /etc/ansible/hosts 主机列表配置文件 #library = /usr/share/my_modules/ # 库文件存放目录 #remote_tmp = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录 #local_tmp = $HOME/.ansible/tmp # 本机的临时命令执行目录 #forks = 5 # 默认并发数 #sudo_user = root # 默认sudo 用户 #ask_sudo_pass = True #每次执行ansible命令是否询问ssh密码 #ask_pass = True #remote_port = 22 #host_key_checking = False # 检查对应服务器的host_key，建议取消注释 #log_path=/var/log/ansible.log #日志文件 #module_name = command #默认模块 主机清单inventoryansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名默认的inventory file为/etc/ansible/hostsinventory file可以有多个，且也可以通过Dynamic Inventory来动态生成 etc/ansible/hosts文件格式 inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明123456[webservers] www1.magedu.com:2222 www2.magedu.com [dbservers]db1.magedu.comdb2.magedu.com 如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机1234[websrvs]www[01:100].example.com[dbsrvs]db-[a:f].example.com ansible-doc: 显示模块帮助ansible-doc [options] [module…]-a 显示所有模块的文档-l, –list 列出可用模块-s, –snippet显示指定模块的playbook片段示例： ansible-doc –l 列出所有模块ansible-doc ping 查看指定模块帮助用法ansible-doc –s ping 查看指定模块帮助用法ansible-vault 功能：管理加密解密yml文件ansible-vault [create|decrypt|edit|encrypt|rekey|view] ansible-vault encrypt hello.yml 加密ansible-vault decrypt hello.yml 解密ansible-vault view hello.yml 查看ansible-vault edit hello.yml 编辑加密文件?ansible-vault rekey hello.yml 修改口令?ansible-vault create new.yml 创建新文件 Ansible-console：2.0+新增，可交互执行命令，支持tab root@test (2)[f:10] $ 执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$设置并发数： forks n 例如： forks 10切换组： cd 主机组 例如： cd web列出当前组主机列表： list列出所有的内置命令： ?或help 示例：123root@all (2)[f:5]listroot@all(2)[f:5] cd appsrvsroot@appsrvs (2)[f:5]listroot@appsrvs(2)[f:5] yum name=httpd state=presentroot@appsrvs (2)[f:5]$ service name=httpd state=started ansible-galaxy连接 https://galaxy.ansible.com 下载相应的roles 安装galaxy ansible-galaxy install geerlingguy.redis 列出所有已安装的galaxy ansible-galaxy list 删除galaxy ansible-galaxy remove geerlingguy.redis 推送命令至远程，效率无限提升，对运维要求较高 ansible-pull ansible-playbook执行playbook示例：ansible-playbook hello.yml1234567cat hello.yml #hello world yml file - hosts: websrvs remote_user: root tasks: - name: hello world command: /usr/bin/wall hello world ansible常用模块Command：在远程主机执行命令，默认模块，可忽略-m选项123[root@centos ~]#ansible all -m command -a 'service vsftpd start'[root@centos ~]#ansible all -m command -a 'echo magedu |passwd --stdin xie'此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等，用shell模块实现 Shell：和command相似，用shell执行命令12[root@centos7 ~]#ansible all -m shell -a 'echo magedu | passwd –stdin xie'调用bash执行命令 类似 cat /tmp/stanley.md | awk -F‘|’ ‘&#123;print 1,2&#125;’ &amp;&gt; /tmp/example.txt 这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器 Script：在远程主机上运行ansible服务器上的脚本12-a "/PATH/TO/SCRIPT_FILE“ansible websrvs -m script -a /data/f1.sh Copy：从服务器复制文件到客户端1234[root@centos7 ~]#ansible all -m copy -a "src=/root/f1 dest=/tmp/f2 owner=xie mode=600 backup=yes"如目标存在，默认覆盖，此处指定先备份[root@centos7 ~]#ansible all -m copy -a "content='test content\n' dest=/tmp/f1.txt"指定内容，直接生成目标文件 Fetch：从客户端取文件至服务器端，copy相反，目录可先tar1[root@centos7 ~]#ansible all -m fetch -a 'src=/root/a.sh dest=/data/scripts' File：设置文件属性123[root@centos7 ~]#ansible all -m file -a "path=/data/f1.txt owner=wang mode=755“[root@centos7 ~]#ansible all -m filw -a "path=/data/f1.txt state=touch"[root@centos7 ~]#ansible all -m file -a 'src=/data/f1.txt dest=/data/f1.txt-link state=link' Hostname：管理主机名1[root@centos7 ~]#ansible websrvs -m hostname -a "name=websrv" Cron：计划任务支持时间：minute，hour，day，month，weekday 创建任务1[root@centos7 ~]#ansible all -m cron -a "minute=*/5 job='/usr/sbin/ntpdate 172.16.0.1 &amp;&gt;/dev/null' name=Synctime" 删除任务1[root@centos7 ~]#ansible all -m cron -a 'state=absent name=Synctime' Yum：管理包12[root@centos7 ~]#ansible all -m yum -a 'name=httpd,memcached,vsftpd state=present' 安装 state=present可以省略不写,系统默认[root@centos7 ~]#ansible all -m yum -a 'name=httpd,memcached,vsftpd state=absent' 删除 Service：管理服务1234[root@centos ~]#ansible all -m service -a 'name=httpd state=stopped'[root@centos ~]#ansible all -m service -a 'name=httpd state=started enabled=yes' 启动服务，并且开机启动[root@centos ~]#ansible all -m service -a 'name=httpd state=reloaded'[root@centos ~]#ansible all -m service -a 'name=httpd state=restarted' User：管理用户1234[root@centos ~]#ansible all -m user -a 'name=user1 comment="test user" uid=2048 home=/app/user1 group=root shell=/sbin/nologin'[root@centos ~]#ansible all -m user -a 'name=sysuser1 system=yes home=/app/sysuser1'[root@centos ~]#ansible all -m user -a 'name=user1 state=absent remove=yes' 删除账号并且删除家目录 Group：管理组12[root@centos ~]#ansible all -m group -a "name=testgroup system=yes"[root@centos ~]#ansible all -m group -a "name=testgroup state=absent"]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化安装系统]]></title>
    <url>%2F2018%2F11%2F18%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[kickstart安装步骤 自动化安装之前我们首先要使用相应的工具去生成相应的文件（应答文件），在我们的系统装好之后，在管理员的家目录下都有这样一个文件anaconda-ks.cfg,此文件中的 kickstart就是我们实现自动化安装的重要文件，那么在配置此文件之前首先要安装kickstart所依赖的服务的包system-config-kickstart使用此工具需要在图形界面下进行具体步骤如下： 首先安装包文件system-config-kickstart 1[root@CentOS6 ~]#yum install system-config-kickstart 安装之后在图形界面下打开system-config-kickstart 1[root@CentOS6 ~]#system-config-kickstart 1centos7上包安装界面时是空白的，此时需要把yum源的[base]改为[development] 查看下是否生成了ks.cfg文件 123456789[root@CentOS6 ~]#ll ks.cfg -rw-r--r-- 1 root root 1345 Nov 18 14:34 ks.cfg[root@CentOS6 ~]#mkdir -pv /var/www/html/ksdir/&#123;6,7&#125;mkdir: created directory `/var/www/html/ksdir'mkdir: created directory `/var/www/html/ksdir/6'mkdir: created directory `/var/www/html/ksdir/7'[root@CentOS6 ~]#mv ks.cfg /var/www/html/ksdir/6/ks_mini.cfg [root@CentOS6 ~]#ll /var/www/html/ksdir/6/ks_mini.cfg-rw-r--r-- 1 root root 1345 Nov 18 14:34 /var/www/html/ksdir/6/ks_mini.cfg 如果对ks_mini.cfg文件进行修改，格式出现错误势必后面的安装也不能正常进行，那么此时我们可以用ksvalidator来进行检查 格式：ksvalidator ks_mini.cfg 如果访问的时候出现没有权限的提示，首先查看该应答文件是否为644权限如果权限不是此时应该修改权限chmod 644 ks6_mini.cfg如果权限是644权限，那么此时应该关闭selinux 关闭方法：vim /etc/selinux/config 将SELINUX=enabled 改为SELINUX=disabled,重启即可 此时已经可以通过刚才生成的文件通过网络来实现自动化安装，点击启动，把刚才的虚拟机重启（此时就需要光盘引导） 此时当你按下ENTER之后，就意味着你可以去休息了，剩下的事情完全自动化安装了。 kickstart文件的格式 命令段：指明各种安装前配置，如键盘类型等 程序包段：指明要安装的程序包组或程序包，不安装的程序包等 12345%packages @group_name package -package%end 脚本段： %pre: 安装前脚本运行环境：运行于安装介质上的微型Linux环境 %post: 安装后脚本运行环境：安装完成的系统 命令段中的命令： 必备命令 authconfig: 认证方式配置authconfig –useshadow –passalgo=sha512bootloader：bootloader的安装位置及相关配置bootloader –location=mbr –driveorder=sda –append=”crashkernel=auto rhgb quiet”keyboard: 设定键盘类型lang: 语言类型part: 创建分区rootpw: 指明root的密码timezone: 时区 可选命令 install OR upgradetext: 文本安装界面networkfirewallselinuxhaltpoweroffrebootrepouser：安装完成后为系统创建新用户url: 指明安装源key –skip 跳过安装号码,适用于rhel版本 制作引导光盘和U盘创建引导光盘： 123456mkdir –pv /app/myisocp -r /misc/cd/isolinux/ /app/myiso/vim /app/myiso/isolinux/isolinux.cfginitrd=initrd.img text ks=cdrom:/myks.cfgcp /root/myks.cfg /app/myiso/mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V "CentOS 6.9 x86_64 boot" -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso /app/myiso/ 注意：以上相对路径都是相对于光盘的根，和工作目录无关 创建U盘启动盘 1dd if=/dev/sr0 of=/dev/sdb mkisofs选项-o 指定映像文件的名称。-b 指定在制作可开机光盘时所需的开机映像文件。-c 制作可开机光盘时，会将开机映像文件中的 no-eltorito-catalog 全部内容作成一个文件。-no-emul-boot 非模拟模式启动。-boot-load-size 4 设置载入部分的数量-boot-info-table 在启动的图像中现实信息-R 或 -rock 使用 Rock RidgeExtensions-J 或 -joliet 使用 Joliet 格式的目录与文件名称-v 或 -verbose 执行时显示详细的信息-T 或 -translation-table 建立文件名的转换表，适用于不支持 Rock Ridge Extensions 的系统上 1234567891011121314151617181920212223[root@CentOS6 ~]#mkdir /data/iso[root@CentOS6 ~]#cp -r /misc/cd/isolinux/ /data/iso[root@CentOS6 ~]#tree /data/iso/data/iso└── isolinux├── boot.cat├── boot.msg├── grub.conf├── initrd.img├── isolinux.bin├── isolinux.cfg├── memtest├── splash.jpg├── TRANS.TBL├── vesamenu.c32└── vmlinuz1 directory, 11 files[root@CentOS6 ~]#cp /var/www/html/ksdir/6/ks_mini.cfg /data/iso/[root@CentOS6 iso]#mkdir ksdir[root@CentOS6 iso]#mv ks_mini.cfg ksdir/[root@CentOS6 iso]#lsisolinux ksdir]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>mkisofs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible的高级用法之playbook和roles]]></title>
    <url>%2F2018%2F09%2F10%2FAnsible%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E4%B9%8Bplaybook%E5%92%8Croles%2F</url>
    <content type="text"><![CDATA[playbook概念playbook是由一个或多个“play” 组成的列表play的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。 Task实际是调用ansible的一个module，将多个play组织在一个playbook中，即可以让它们联合起来，按事先编排的机制执行预定义的动作Playbook采用YAML语言编写 YAML介绍&ensp;&ensp;&ensp;&ensp;YAML是一个可读性高的用来表达资料序列的格式。 YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。 Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者. YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 特性 YAML的可读性好 YAML和脚本语言的交互性好 YAML使用实现语言的数据类型 YAML有一个一致的信息模型 YAML易于实现 YAML可以基于流来处理 YAML表达能力强，扩展性好 YAML语法简介 在单一档案中，可用连续三个连字号(—)区分多个档案。另外，还有选择性的连续三个点号( … )用来表示档案结尾 次行开始正常写Playbook的内容，一般建议写明该Playbook的功能 使用#号注释代码 缩进必须是统一的，不能空格和tab混用 缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的 YAML文件内容是区别大小写的，k/v的值均需大小写敏感 k/v的值可同行写也可换行写。同行使用:分隔 v可是个字符串，也可是另一个列表 一个完整的代码块功能需最少元素需包括 name: task 一个name只能包括一个task YAML文件扩展名通常为yml或yaml List：列表，其所有元素均使用“-” 打头示例： 123456# A list of tasty fruits - Apple- Orange- Strawberry- Mango Dictionary：字典，通常由多个key与value构成示例： 12345---# An employee record name: Example Developer job: Developer skill: Elite 也可以将key:value放置于{}中进行表示，用,分隔多个key:value 示例： 123---# An employee record &#123;name: Example Developer, job: Developer, skill: Elite&#125; YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔示例1234567891011121314name: John Smithage: 41gender: Malespouse:name: Jane Smithage: 37gender: Femalechildren:- name: Jimmy Smithage: 17gender: Male- name: Jenny Smithage 13gender: Female Playbook核心元素 Hosts 执行的远程主机列表 Tasks 任务集 Varniables 内置变量或自定义变量在playbook中调用 Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。 ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断 1ansible-playbook –t tagsname useradd.yml playbook基础组件Hosts&ensp;&ensp;&ensp;&ensp;playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。 hosts用于指定要执行指定任务的主机，须事先定义在主机清单中可以是如下形式：1234one.example.comone.example.com:two.example.com192.168.1.50192.168.1.* Websrvs:dbsrvs 或者，两个组的并集Websrvs:&amp;dbsrvs 与，两个组的交集webservers:!phoenix 在websrvs组，但不在dbsrvs组示例: - hosts: websrvs：dbsrvs remote_user&ensp;&ensp;&ensp;&ensp;用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户12345678- hosts: websrvsremote_user: roottasks:- name: test connectionping:remote_user: magedusudo: yes 默认sudo为rootsudo_user:wang sudo为wang task列表和action&ensp;&ensp;&ensp;&ensp;play的主体部分是task list。 task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后，再开始第二个任务task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出 tasks：任务列表两种格式： action: module arguments module: arguments 建议使用注意：shell和command模块后面跟命令，而非key=value 任务可以通过”tags“打标签，可在ansible-playbook命令上使用-t指定进行调用示例：12345678910111213141516tasks: - name: disable selinux command: /sbin/setenforce 0 如果命令或脚本的退出码不为零，可以使用如下方式替代 tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand || /bin/true 或者使用ignore_errors来忽略错误信息 tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand ignore_errors: True 运行playbook的方式 ansible-playbook &lt;filename.yml&gt; … [options] 常见选项:–check -C 只检测可能会发生的改变，但不真正执行操作–list-hosts 列出运行任务的主机123456789[root@centos7 playbook]#ansible-playbook test.yml --list-hostsplaybook: test.yml play #1 (appsrvs): appsrvs TAGS: [] pattern: [u'appsrvs'] hosts (2): 192.168.183.132 192.168.183.129 –list-tags 列出tag123456[root@centos7 playbook]#ansible-playbook test.yml --list-tags playbook: test.yml play #1 (appsrvs): appsrvs TAGS: [] TASK TAGS: [] –list-tasks 列出task1234567[root@centos7 playbook]#ansible-playbook test.yml --list-tasksplaybook: test.yml play #1 (appsrvs): appsrvs TAGS: [] tasks: first task TAGS: [] second task TAGS: [] –limit 主机列表 只针对主机列表中的主机执行1[root@centos7 playbook]#ansible-playbook test.yml --limit 192.168.183.129 -v -vv -vvv 显示过程 Playbook示例安装httpd，并且开机启动1234567891011121314151617181920212223242526272829303132333435363738[root@cetos7 ~]#vim /etc/ansible/hosts ##[dbservers]##db01.intranet.mydomain.net##db02.intranet.mydomain.net##10.25.1.56##10.25.1.57# Here's another example of host ranges, this time there are no# leading 0s:## db-[99:101]-node.example.com [appsrvs] #添加分组192.168.183.132192.168.183.129~ "/etc/ansible/hosts" 50L, 1100C 47,0-1 Bot[root@centos7 playbook]#vim httpd.yml ---- hosts: appsrvs remote_user: root tasks: - name: creat group group: name=apache system=yes gid=80 - name: creat user user: name=apache group=apache uid=80 shell=/sbin/nologin home=/usr/share/httpd system=yes password='$1$MrKn.0gj$CvMvkger.03UzBwQIrya.0' - name: install package yum: name=httpd - name: config file copy: src=/root/playbook/httpd.conf dest=/etc/httpd/conf/ backup=yes - name: service service: name=httpd state=started enabled=yes ~[root@centos7 playbook]#ansible-playbook httod.yml handlers和notify结合使用触发条件Handlers是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操 作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称handler，也即notify中调用handler中定义的操作 &ensp;&ensp;&ensp;&ensp;如果httpd.conf文件内容修改了再运行一遍httpd.yml，只有config file发生改变，其他任务不会继续做了，所以把上述的playbook改写一下,加上notify和handlers：12345678910111213141516171819202122[root@centos7 playbook]#vim httpd.yml ---- hosts: appsrvs remote_user: root tasks: - name: creat group group: name=apache system=yes gid=80 - name: creat user user: name=apache group=apache uid=80 shell=/sbin/nologin home=/usr/share/httpd system=yes password='$1$MrKn.0gj$CvMvkger.03UzBwQIrya.0' - name: install package yum: name=httpd - name: config file copy: src=/root/playbook/httpd.conf dest=/etc/httpd notify: restart service/conf/ backup=yes - name: service service: name=httpd state=started enabled=yes handlers: - name: restart service service: name=httpd state=restart[root@centos7 playbook]#ansible-playbook httod.yml如果我们httpd端口80 改成8080，再运行一遍`ansible-playbook`时，这时就只会触发重启httpd服务 Playbook中tags使用12345678910111213141516171819202122[root@centos7 playbook]#vim httpd.yml ---- hosts: appsrvs remote_user: root tasks: - name: creat group group: name=apache system=yes gid=80 - name: creat user user: name=apache group=apache uid=80 shell=/sbin/nologin home=/usr/share/httpd system=yes password='$1$MrKn.0gj$CvMvkger.03UzBwQIrya.0' - name: install package yum: name=httpd tags: install - name: config file copy: src=/root/playbook/httpd.conf dest=/etc/httpd tags: config notify: restart service/conf/ backup=yes - name: service service: name=httpd state=started enabled=yes handlers: - name: restart service service: name=httpd state=restart 给playbook打上tags我们就可以单独的执行tags的那部分tasks [root@centos7 playbook]#ansible-playbook -t install httpd.yml 仅仅执行了安装httpd Playbook中变量使用变量来源： ansible setup facts 远程主机的所有变量都可直接调用 在/etc/ansible/hosts中定义 普通变量：主机组中主机单独定义，优先级高于公共变量公共（组）变量：针对主机组中所有主机定义统一变量 通过命令行指定变量，优先级最高 ansible-playbook –e varname=value 在playbook中定义 123vars:- var1: value1- var2: value2 在独立的变量YAML文件中定义 在role中定义 变量命名变量名仅能由字母、数字和下划线组成，且只能以字母开头 变量定义：key=value示例：http_port=80 变量调用方式通过 调用变量，且变量名前后必须有空格，有时用“”才生效 ansible-playbook –e 选项指定1ansible-playbook test.yml -e “hosts=www user=magedu” 示例使用setup变量示例：var.yml1234567- hosts: websrvs remote_user: root tasks: - name: create log file file: name=/var/log/ &#123;&#123; ansible_fqdn &#125;&#125; state=touchansible-playbook var.yml 变量示例：var.yml12345678910111213- hosts: websrvs remote_user: root vars: - username: user1 - groupname: group1 tasks: - name: create group group: name=&#123;&#123; groupname &#125;&#125; state=present - name: create user user: name=&#123;&#123; username &#125;&#125; state=presentansible-playbook var.ymlansible-playbook -e "username=user2 groupname=group2” var2.yml 主机变量 可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用示例：123[websrvs]www1.magedu.com http_port=80 maxRequestsPerChild=808www2.magedu.com http_port=8080 maxRequestsPerChild=909 组变量 组变量是指赋予给指定组内所有主机上的在playbook中可用的变量示例：123456[websrvs]www1.magedu.comwww2.magedu.com[websrvs:vars]ntp_server=ntp.magedu.comnfs_server=nfs.magedu.com 普通变量 123[websrvs]192.168.99.101 http_port=8080 hname=www1192.168.99.102 http_port=80 hname=www2 公共（组）变量 1234567[websvrs:vars]http_port=808mark=“_”[websrvs]192.168.99.101 http_port=8080 hname=www1192.168.99.102 http_port=80 hname=www2ansible websvrs –m hostname –a 'name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;' 命令行指定变量： 1ansible websvrs –e http_port=8000 –m hostname –a 'name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; http_port &#125;&#125;' 模板templates 文本文件，嵌套有脚本（使用模板编程语言编写） Jinja2语言，使用字面量，有下面形式 字符串：使用单引号或双引号数字：整数，浮点数列表：[item1, item2, …]元组：(item1, item2, …)字典：{key1:value1, key2:value2, …}布尔型：true/false算术运算：+, -, *, /, //, %, **比较操作：==, !=, &gt;, &gt;=, &lt;, &lt;=逻辑运算：and, or, not流表达式：For If When templates功能：根据模块文件动态生成对应的配置文件 templates文件必须存放于templates目录下，且命名为 .j2 结尾 yaml/yml 文件需和templates目录平级，目录结构如下： 1234./├── temnginx.yml└── templates └── nginx.conf.j2 Playbook中template变更替换 Playbook中template算术运算 Templates示例利用templates 同步nginx配置文件，并修改配置文件nginx.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[root@centos7 playbook]#mkdir templates[root@centos7 playbook]#mv nginx.conf templates/nginx.conf.j2[root@centos7 playbook]#tree.├── test_templ.yml├── templates └── nginx.conf.j2[root@centos7 playbook]#vim test_templ.yml--- - hosts: appsrvs remote_user: root tasks: - name: install yum: name=nginx - name: template template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart - name: service service: name=nginx state=started enabled=yes handlers: - name: restart service: name=nginx state=restarted[root@centos7 playbook]#ansible-playbook test_templ.yml.........省略结果[root@centos7 playbook]#ansible appsrvs -a 'ss -ntlp' #查看80端口是否开启[root@centos7 playbook]#ansible appsrvs -m shell -a 'ps axu | grep nginx'192.168.183.137 | CHANGED | rc=0 &gt;&gt;root 16688 0.0 0.1 120812 2228 ? Ss 21:15 0:00 nginx: master process /usr/sbin/nginxnginx 16689 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processnginx 16690 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processroot 16755 0.0 0.0 113172 1196 pts/1 S+ 21:15 0:00 /bin/sh -c ps axu | grep nginxroot 16757 0.0 0.0 112704 940 pts/1 S+ 21:15 0:00 grep nginx192.168.183.136 | CHANGED | rc=0 &gt;&gt;root 18759 0.0 0.1 122924 2100 ? Ss 20:46 0:00 nginx: master process /usr/sbin/nginxnginx 18760 0.0 0.1 125472 3540 ? S 20:46 0:00 nginx: worker processroot 36053 0.0 0.0 113128 1196 pts/1 S+ 21:15 0:00 /bin/sh -c ps axu | grep nginxroot 36055 0.0 0.0 112664 948 pts/1 S+ 21:15 0:00 grep nginx[root@centos7 playbook]#ansible appsrvs -m shell -a 'ps axu | grep nginx' 192.168.183.137 | CHANGED | rc=0 &gt;&gt;root 16688 0.0 0.1 120812 2228 ? Ss 21:15 0:00 nginx: master process /usr/sbin/nginxnginx 16689 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processnginx 16690 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processroot 16755 0.0 0.0 113172 1196 pts/1 S+ 21:15 0:00 /bin/sh -c ps axu | grep nginxroot 16757 0.0 0.0 112704 940 pts/1 S+ 21:15 0:00 grep nginx192.168.183.136 | CHANGED | rc=0 &gt;&gt;root 18759 0.0 0.1 122924 2100 ? Ss 20:46 0:00 nginx: master process /usr/sbin/nginxnginx 18760 0.0 0.1 125472 3540 ? S 20:46 0:00 nginx: worker processroot 36053 0.0 0.0 113128 1196 pts/1 S+ 21:15 0:00 /bin/sh -c ps axu | grep nginxroot 36055 0.0 0.0 112664 948 pts/1 S+ 21:15 0:00 grep nginx[root@centos7 playbook]#ansible appsrvs -m setup -a 'filter=ansible_processor_count'192.168.183.136 | SUCCESS =&gt; &#123; "ansible_facts": &#123; "ansible_processor_count": 1 &#125;, "changed": false&#125;192.168.183.137 | SUCCESS =&gt; &#123; "ansible_facts": &#123; "ansible_processor_count": 2 &#125;, "changed": false&#125;worker process 与 CPU数量一致[root@centos7 playbook]#vim templates/nginx.conf.j2.....省略.....worker_processes &#123;&#123; ansible_processor_count*2 &#125;&#125;; #Playbook中template算术运算.....省略.....[root@centos7 playbook]#ansible appsrvs -m shell -a 'ps axu | grep nginx' 192.168.183.136 | CHANGED | rc=0 &gt;&gt;root 18759 0.0 0.1 122924 2100 ? Ss 20:46 0:00 nginx: master process /usr/sbin/nginxnginx 18760 0.0 0.1 125472 3540 ? S 20:46 0:00 nginx: worker processnginx 18761 0.0 0.1 125472 3540 ? S 20:46 0:00 nginx: worker processroot 36485 0.0 0.0 113128 1196 pts/1 S+ 21:36 0:00 /bin/sh -c ps axu | grep nginxroot 36487 0.0 0.0 112664 944 pts/1 S+ 21:36 0:00 grep nginx192.168.183.137 | CHANGED | rc=0 &gt;&gt;root 16688 0.0 0.1 120812 2228 ? Ss 21:15 0:00 nginx: master process /usr/sbin/nginxnginx 16689 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processnginx 16690 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processnginx 16691 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processnginx 16692 0.0 0.1 123360 3524 ? S 21:15 0:00 nginx: worker processroot 17220 0.0 0.0 113172 1200 pts/1 S+ 21:36 0:00 /bin/sh -c ps axu | grep nginxroot 17222 0.0 0.0 112704 940 pts/1 S+ 21:36 0:00 grep nginx when&ensp;&ensp;&ensp;&ensp;条件测试:如果需要根据变量、 facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过when语句实现，在task中使用，jinja2的语法格式 when语句在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法示例：12345678910111213141516171819202122232425[root@centos7 playbook]#tree templates/templates/├── httpd6.conf.j2└── httpd7.conf.j2[root@centos7 playbook]#vim httpd.yml ---- hosts: appsrvs remote_user: root tasks: - name: install yum: name=httpd - name: template1 template: src=httpd6.conf.j2 dest=/etc/httpd/conf/httpd.conf when: ansible_distribution_major_version=="6" notify: restart - name: template2 template: src=httpd7.conf.j2 dest=/etc/httpd/conf/httpd.conf when: ansible_distribution_major_version=="7" notify: restart - name: service service: name=httpd state=started enabled=yes handlers: - name: restart service: name=httpd state=restart 迭代：with_items迭代：当有需要重复性执行的任务时，可以使用迭代机制 对迭代项的引用，固定变量名为”item”要在task中使用with_items给定要迭代的元素列表列表格式： 字符串字典 示例：12345- name: add several users user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel with_items: - testuser1 - testuser2 迭代嵌套子变量例:123456789101112131415- hosts：websrvs remote_user: root tasks: - name: add groups group: name=&#123;&#123; item &#125;&#125; with_items: - group1 - group2 - group3 - name: add users user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; with_items: - &#123; name: 'user1', group: 'group1' &#125; - &#123; name: 'user2', group: 'group2' &#125; - &#123; name: 'user3', group: 'group3' &#125; roles&ensp;&ensp;&ensp;&ensp;ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲,roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。 复杂场景：建议使用roles，代码复用度高 变更指定主机或主机组如命名不规范维护和传承成本大某些功能需多个Playbook，通过includes即可实现 角色(roles)：角色集合roles/ mysql/ httpd/ nginx/ memcached/ roles目录结构每个角色，以特定的层级目录结构进行组织roles目录结构： playbook.ymlroles/project/tasks/files/vars/templates/handlers/default/ 不常用meta/ 不常用 Roles各目录作用/roles/project/ :项目名称,有以下子目录files/ ：存放由copy或script模块等调用的文件templates/：template模块查找所需要模板文件的目录tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含handlers/：至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含vars/：定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含default/：设定默认变量时使用此目录中的main.yml文件 创建role创建role的步骤 创建以roles命名的目录 在roles目录中分别创建以各角色名称命名的目录，如webservers等 在每个角色命名的目录中分别创建files、 handlers、 meta、 tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建 在playbook文件中，调用各角色 针对大型项目使用Roles进行编排123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222[root@centos7 playbook]#mkdir roles[root@centos7 playbook]#mkdir roles/httpd[root@centos7 playbook]#tree roles/roles/└── httpd1 directories, 0 files[root@centos7 playbook]#mkdir roles/httpd/&#123;files,tasks,templates,handlers,vars&#125;[root@centos7 playbook]#tree roles/roles/└── httpd ├── files ├── handlers ├── tasks ├── templates └── vars6 directories, 0 files[root@centos7 playbook]#cd roles/httpd/[root@centos7 httpd]#tree.├── files├── handlers├── tasks├── templates└── vars5 directories, 0 files[root@centos7 httpd]#cd tasks/[root@centos7 tasks]#touch user.yml group.yml config.yml install.yml service.yml[root@centos7 tasks]#vim group.yml - name: useradd group group: name=apache system=yes gid=80 [root@centos7 tasks]#vim user.yml - name: useradd user user: name=apache group=apache shell=/sbin/nologin home=/usr/share/httpd system=yes [root@centos7 tasks]#vim install.yml - name: install package yum: name=httpd [root@centos7 tasks]#vim config.yml - name: config file copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes notify: restart [root@centos7 tasks]#vim service.yml - name: service service: name=httpd state=started enabled=yes[root@centos7 tasks]#lltotal 20-rw-r--r-- 1 root root 76 Nov 24 00:41 config.yml-rw-r--r-- 1 root root 61 Nov 24 00:30 group.yml-rw-r--r-- 1 root root 42 Nov 24 00:39 install.yml-rw-r--r-- 1 root root 62 Nov 24 00:42 service.yml-rw-r--r-- 1 root root 107 Nov 24 00:34 user.yml[root@centos7 tasks]#vim main.yml- include: group.yml- include: user.yml- include: install.yml- include: config.yml- include: service.yml [root@centos7 tasks]#cd ..[root@centos7 httpd]#vim handlers/main.yml- name: restart service: name=httpd state=restarted[root@centos7 httpd]#cp /etc/httpd/conf/httpd.conf files/[root@centos7 httpd]#tree.├── files│ └── httpd.conf├── handlers│ └── main.yml├── tasks│ ├── config.yml│ ├── group.yml│ ├── install.yml│ ├── main.yml│ ├── service.yml│ └── user.yml├── templates└── vars5 directories, 8 files [root@centos7 httpd]#cd ../../[root@centos7 playbook]#vim httpd_roles.yml---- hosts: appsrvs remote_user: root roles: - role: httpd [root@centos7 playbook]#ansible-playbook httpd_roles.yml把httpd的文件复制一份到nginx里，然后改改[root@centos7 roles]#cp -r httpd/ nginx/[root@centos7 roles]#tree.├── httpd│ ├── files│ │ └── httpd.conf│ ├── handlers│ │ └── main.yml│ ├── tasks│ │ ├── config.yml│ │ ├── group.yml│ │ ├── install.yml│ │ ├── main.yml│ │ ├── service.yml│ │ └── user.yml│ ├── templates│ └── vars└── nginx ├── files │ └── httpd.conf ├── handlers │ └── main.yml ├── tasks │ ├── config.yml │ ├── group.yml │ ├── install.yml │ ├── main.yml │ ├── service.yml │ └── user.yml ├── templates └── vars12 directories, 16 files[root@centos7 roles]#cd nginx/[root@centos7 nginx]#tree.├── files│ └── httpd.conf├── handlers│ └── main.yml├── tasks│ ├── config.yml│ ├── group.yml│ ├── install.yml│ ├── main.yml│ ├── service.yml│ └── user.yml├── templates└── vars5 directories, 8 files[root@centos7 nginx]#rm -f tasks/&#123;group,user&#125;.yml[root@centos7 nginx]#tree.├── files│ └── httpd.conf├── handlers│ └── main.yml├── tasks│ ├── config.yml│ ├── install.yml│ ├── main.yml│ └── service.yml├── templates└── vars5 directories, 6 files[root@centos7 nginx]#cp /etc/nginx/nginx.conf templates/nginx.conf.j2[root@centos7 nginx]#tree.├── files│ └── httpd.conf├── handlers│ └── main.yml├── tasks│ ├── config.yml│ ├── install.yml│ ├── main.yml│ └── service.yml├── templates│ └── nginx.conf.j2└── vars5 directories, 7 files[root@centos7 nginx]#cd tasks/[root@centos7 tasks]#tree.├── config.yml├── install.yml├── main.yml└── service.yml0 directories, 4 files[root@centos7 tasks]#vim config.yml - name: config file template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart[root@centos7 tasks]#vim install.yml - name: install package yum: name=nginx [root@centos7 tasks]#vim main.yml - include: install.yml - include: config.yml- include: service.yml[root@centos7 tasks]#vim service.yml - name: service service: name=nginx state=started enabled=yes [root@centos7 tasks]#cd ../../../[root@centos7 playbook]#vim nginx_roles.yml- hosts: appsrvs remote_user: root roles: - role: nginx [root@centos7 playbook]#ansible-playbook nginx_roles.yml]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>playbook</tag>
        <tag>role</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘存储和文件系统]]></title>
    <url>%2F2018%2F05%2F19%2F%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[磁盘结构设备类型（1）块设备：block ，存取单位“块”，磁盘 （2）字符设备：char ，存取单位“字符”，键盘 设备号码（1）主设备号：major number, 标识设备类型 （2）次设备号：minor number, 标识同一类型下的不同设备 机械硬盘和固态硬盘&ensp;&ensp;&ensp;&ensp;机械硬盘（HDD）：即是传统普通硬盘，主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。机械硬盘中所有的盘片都装在一个旋转轴上，每张盘片之间是平行的，在每个盘片的存储面上有一个磁头，磁头与盘片之间的距离比头发丝的直径还小，所有的磁头联在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向运动，加上盘片每分钟几千转的高速旋转，磁头就可以定位在盘片的指定位置上进行数据的读写操作。数据通过磁头由电磁流来改变极性方式被电磁流写到磁盘上，也可以通过相反方式读取。硬盘为精密设备，进入硬盘的空气必须过滤。 &ensp;&ensp;&ensp;&ensp;固态硬盘（SSD）：用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH 芯片、DRAM 芯片）组成。固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也与普通硬盘一致。 比较： 相较于HDD ，SSD 在防震抗摔、传输速率、功耗、重量、噪音上有明显优势，SSD 传输速率性能是HDD 的2倍 相较于SSD ，HDD 在价格、容量、使用寿命上占有绝对优势 硬盘有价，数据无价，目前SSD 不能完全取代HHD 设备文件① 磁盘设备的设备文件命名： IDE: /dev/hd SCSI,SATA,SAS,USB: /dev/sd ② 不同磁盘标识：a-z,aa,ab… ​ /dev/sda, /dev/sdb, … /dev/sdaa,/dev/sdab… 同一设备上的不同分区：1,2, … ​ /dev/sda1, /dev/sda5 ③ 机械硬盘存储术语 head ：磁头 track ：磁道 cylinder: 柱面 secotr: 扇区，512bytes（最小单位） 两种寻址方法：CHS和LBA CHS： 采用24bit 位寻址 其中前10 位表示cylinder ，中间8 位表示head ，后面6 位表示sector。 。 最大寻址空间8GB LBA （logical block addressing）： LBA 是一个整数，通过转换成CHS 格式完成磁盘具体寻址 LBA 采用48 个bit 位寻址 最大寻址空间128PB 由于CHS 寻址方式的寻址空间在大概8GB 以内，所以在磁盘容量小于大概8GB 时，可以使用CHS 寻址方式或是LBA 寻址方式；在磁盘容量大于大概8GB 时，则只能使用LBA 寻址方式 使用分区空间1、 设备识别 2、 设备分区 3、 文件系统类型格式化 4、 在/etc/fstab 文件中创建条目 5、 mount 挂载新的文件系统 磁盘分区为什么分区1、 优化I/O 性能 2、 实现磁盘空间配额限制 3、 提高修复速度 4、 隔离系统和程序 5、 安装多个OS 6、 采用不同文件系统 分区两种分区方式：MBR ，GPT （1）MBR: Master Boot Record ，1982年， 使用32位表示扇区数 ， 分区不超过2T （2）如何分区：按柱面 （2）0 磁道0 扇区：512bytes 446bytes: boot loader 64bytes ：分区表 16bytes: 标识一个分区 2bytes: 55AA，结束标志 （2）4 个主分区；3 主分区+1 扩展(N 个逻辑分区) MBR分区结构&ensp;&ensp;&ensp;&ensp;硬盘主引导记录MBR 主要由 4 个部分组成 1、主引导程序（偏移地址0000H–0088H ），它负责从活动分区中装载，并运行系统引导程序。 2、出错信息数据区，偏移地址0089H–00E1H 为出错信息，00E2H–01BDH 全为0 字节。 3、分区表（DPT,Disk Partition Table ）含4 个分区项，偏移地址01BEH–01FDH, 每个分区表项长16 个字节，共64 字节为分区项1 、分区项2 、分区项3 、分区项4 4、 结束标志字，偏移地址01FE–01FF 的2 个字节值为结束标志 55AA GPT分区1、GPT:GUID （Globals Unique Identifiers） partitiontable 支持128个分区，使用64 位，支持8Z（512Byte/block ）64Z （4096Byte/block） 2、使用128 位UUID(Universally Unique Identifier) 表示磁盘区 和分区 GPT 分区表自动备份在头和尾两份，并有CRC 校验位 3、UEFI ( 统一扩展固件接口) 硬件支持GPT ，使操作系统启动 管理分区列出块设备123fdisk -l /dev/sda 看硬盘分区表lsblkcat /proc/partitions 查看内核是否已经识别新的分区 创建分区使用的命令（1） fdisk 创建MBR 分区 fdisk /dev/sdX进行分区（交互式），建立分区时 m 帮助 n 建立分区，建立分区时先选择 p主分区primary partition 或e 选择扩展分区extended，建议前3个建立逻辑分区，最后把所有空间给4扩展分区，有扩展分区可以创建多个逻辑分区。 d 删除分区 p 显示分区信息 t 转换分区类型 a 将指定分区设置/取消 活动分区 第一位为80活动 L 查看分区类型 o 重建分区表 v 验证分区表，显示剩余没有被分区划分的扇区数量 g 创建GPT格式的分区（centos7)不推荐使用，最好用gdisk q 退出不保存 w 退出并保存,同步 注：因为fdisk 是交互式创建分区，所以写入脚本时需要： echo -e &quot;n\np\n1\n\n+1G\nw\n&quot; |fdisk /dev/sdb 来实现非交互创建分区 （2） gdisk 创建GPT 分区（用法和fdisk相似） n创建分区时，直接从2-128进行分区，不分主分区，扩展分区 （3） parted 高级分区操作（创建、复制、调整大小等等）实时性，小心使用，不用再w已经保存，可以直接非交互式创建分区，aix, amiga, bsd, dvh, gpt, mac, msdos, pc98, sun, loop 都能创建。（不常用） parted /dev/sdX help 寻求帮助，有很清晰的帮助的信息。 mklabel help 有mklabel使用帮助信息 mklabel msdos 选择msdos 方式分区 mkpart 开始创建分区 rm 删除分区 p 查看分区信息 q 退出 （4）重置内存中分区信息（当系统正在使用的分区修改时，内存不会改变） 1234567centos 5和7可以使用新增分区时，同步 partx -a /dev/sdXcentos6新增分区时，同步 kpartx -a /dev/DEVICE -f: force删除分区时，同步 partx -d /dev/sdX 所有系统都能用，centos 6也可以 文件系统&ensp;&ensp;&ensp;&ensp;文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统 查看支持的文件系统：/lib/modules/uname –r/kernel/fs 文件系统类型（1） Linux 文件系统 ext2(Extended file system) :适用于那些分区容量不是太大，更新也不频繁的情况，例如 /boot 分区 ext3:是 ext2 的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中恢复。它通常被用作通用的文件系统 ext4:是 ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件(16TB)、最大1EB的文件系统，以及速度的提升 xfs：SGI，支持最大8EB的文件系统 btrfs（Oracle）, reiserfs, jfs（AIX）, swap （2） 光盘：iso9660 （3） Windows ：FAT32, exFAT,NTFS （4） Unix: FFS （fast ）, UFS （unix ）, JFS2 （5） 网络文件系统：NFS, CIFS （6） 集群文件系统：GFS2, OCFS2 （oracle） 例：11.11 淘宝 （7） 分布式文件系统： fastdfs,ceph, moosefs, mogilefs,glusterfs, Lustre （8） RAW：未经处理或者未经格式化产生的文件系统 文件系统分类 根据其是否支持”journal” 功能： 日志型文件系统: ext3, ext4, xfs, … 非日志型文件系统: ext2, vfat 文件系统的组成部分： ​ 内核中的模块：ext4, xfs, vfat ​ 用户空间的管理工具：mkfs.ext4, mkfs.xfs,mkfs.vfat Linux的虚拟文件系统：VFS 查前支持的文件系统：cat /proc/filesystems 创建文件系统（1）mkfs 命令 mkfs. 能创建很多类文件系统 例：mkfs.xfs /dev/sda1 给/dev/sda1创建xfs类型的文件系统 （ext# xfs btrfs vfa） mkfs -t 是个c写的脚本，就是调用mkfs. 命令 例：mkfs -t ext4 /dev/sda1 给/dev/sda1创建ext4类型的文件系统 -f 强制重建，如果这个设备已经分过其他格式的文件系统了 （2）mke2fs ：创建文件系统，ext系列文件系统专用管理工具， 例：mke2fs -t ext4 -L test /dev/sdc1 给/dev/sdc1创建ext4卷标为test的文件系统 -t {ext2|ext3|ext4} 格式 -b {1024|4096} block快大小 -L ‘LABEL’ 卷标 -j: 于 相当于 -t ext3 mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3 -i #: 为数据空间中每多少个字节创建一个inode ；此大小不应该小于block 的大小 -N # ：指定分区中创建多少个inode -I 一个inode 记录占用的磁盘空间大小，128—4096 -m #: 默认5%, 为管理人员预留空间占总空间的百分比 -O FEATURE[,…] ：启用指定特性（只能开启以下特性） -O ^FEATURE 禁用指定特性 （3）tune2fs：修改文件系统信息，重新设定ext 系列文件系统可调整参数的值 例：tune2fs -o acl /dev/sdb2 开启/dev/sdb2的acl功能 -l ：查看指定文件系统超级块信息；super block -L ‘LABEL’ ：修改卷标（ext） mkfs -L ‘LABEL’ 或 mke2fs -L ‘LABEL’ 创建时设置卷标 e2label /dev/sd# 查看卷标 e2label /dev/sd# ‘LABEL’ 重命名卷标 -m # ：修预留给管理员的空间百分比 -j: 将ext2 升级为ext3 -O: 文件系统属性启用或禁用, –O ^has_journal -o: 调整文件系统的默认挂载选项，–o ^acl （centos7里默认开启acl 6 默认不开启） -U UUID: 修改UUID号 （4）查看信息 blkid：块设备属性信息查看（centos 7里默认显示sr0 6 里需blkid /dev/sr0显示光盘） -U UUID: 根据指定的UUID 来查找对应的设备 -L LABEL ：根据指定的LABEL findfs：查找分区(ext) findfs [options] LABEL= findfs [options] UUID= dumpe2fs /dev/sda# 查看文件系统信息：superblock信息及block group信息 -h ：查看超级块，不显示block group而只显示superblock 与tune2fs -l一致 小知识：超级块就是文件系统的内置，指定文件系统类型 block group 0里有super block ，后奇数组都有备份，能用于修复 （5）文件系统检测和修复 常发生于死机或者非正常关机之后，挂载为文件系统有几率标记为“no clean” ” 注意：一定不要在挂载状态下修复 fsck: File System Check​ fsck.FS_TYPE​ fsck -t FS_TYPE​ -p 自动修复错误​ -r 交互式修复错误​ FS_TYPE 一定要与分区上已经文件类型相同 e2fsck：ext系列文件专用的检测修复工具​ -y 自动回答为yes​ -f 强制修复 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[root@CentOS6 ~]#lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsdb 8:16 0 200G 0 disk ├─sdb1 8:17 0 10G 0 part ├─sdb2 8:18 0 2G 0 part └─sdb3 8:19 0 1K 0 part sda 8:0 0 200G 0 disk ├─sda1 8:1 0 1G 0 part /boot├─sda2 8:2 0 48.8G 0 part /├─sda3 8:3 0 29.3G 0 part /data├─sda4 8:4 0 1K 0 part └─sda5 8:5 0 2G 0 part [SWAP]sr0 11:0 1 3.7G 0 rom /media/CentOS_6.10_Final[root@CentOS6 ~]#dd if=/dev/zero of=/dev/sdb2 bs=1M count=2020+0 records in20+0 records out20971520 bytes (21 MB) copied, 0.110713 s, 189 MB/s[root@CentOS6 ~]#tune2fs -l /dev/sdb2tune2fs 1.41.12 (17-May-2010)tune2fs: Bad magic number in super-block while trying to open /dev/sdb2Couldn't find valid filesystem superblock.[root@CentOS6 ~]#fsck /dev/sdb2 -yfsck from util-linux-ng 2.17.2e2fsck 1.41.12 (17-May-2010)fsck.ext2: Superblock invalid, trying backup blocks.../dev/sdb2 was not cleanly unmounted, check forced.Resize inode not valid. Recreate? yesPass 1: Checking inodes, blocks, and sizesRoot inode is not a directory. Clear? yesPass 2: Checking directory structurePass 3: Checking directory connectivityRoot inode not allocated. Allocate? yes/lost+found not found. Create? yesPass 4: Checking reference countsPass 5: Checking group summary informationBlock bitmap differences: +(0--616)Fix? yesFree blocks count wrong for group #0 (32144, counted=32149).Fix? yesFree blocks count wrong (517078, counted=517083).Fix? yesInode bitmap differences: +1 +(3--10)Fix? yesFree inodes count wrong for group #0 (7732, counted=7733).Fix? yesDirectories count wrong for group #0 (3, counted=2).Fix? yesFree inodes count wrong (131636, counted=131637).Fix? yes/dev/sdb2: ***** FILE SYSTEM WAS MODIFIED *****/dev/sdb2: 11/131648 files (0.0% non-contiguous), 9045/526128 blocks 挂载，卸载任何块设备都不能直接访问，需挂载在目录上访问 挂载: 将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为（挂载的设备必须有文件系统） 卸载:为解除此关联关系的过程 mount [-选项] DEVICE（设备） MOUNT_POINT（挂载点） （1）device ：指明要挂载的设备 设备文件：例如/dev/sda5 卷标：-L ‘LABEL’, 如 例如 -L mage UUID, -U ‘UUID’ （2）挂载点下原有文件在挂载完成后会被临时隐藏 事先存在；建议使用空目录，进程正在使用中的设备无法被卸载 （3）/etc/mtab： 文件显示当前已挂载的所有设备（在CentOS 7中，是/proc/mounts的软连接，查看结果一样，centos 6中，ASCII text，查询结果和/proc/mounts不一样） mount：挂载常用命令选项查看挂载情况：findmnt 查看所有设备挂载情况（树状结构显示） findmnt 设备 查看单个设备的挂载情况 mount ：查看所有设备挂载情况 cat /proc/mounts：查看内核追踪到的已挂载的所有设备 mount -选项 设备 挂载点 -t：vsftype ：指定要挂载的设备上的文件系统类型（不常用，不加-t默认自带自己的文件系统类型），有时，系统报错提示，没指定文件系统类型，-t指定后，仍然有错。（注释1） -r：readonly ，只读挂载，不能进行其他操作，和权限无关，介质只能读，多用于冷备份。在mount 查询时时显示 ro 1例：mount -r /dev/sdb1 /app/sdb1 将/dev/sdb1只读挂载到/app/sdb上 -w：read and write, 读写挂载（defaults默认） -n：隐藏挂载信息不显示 ，但在/proc/mounts可以查到，卸载只能 umount /app/sdb2（挂载点） -a：自动挂载/etc/fstab文件没有挂载的设备( 定义在了/etc/fstab文件中，且挂载选项中有auto 功能，默认中包括) ，不看已挂载过的设备，如果在/etc/fstab里挂载过的设备修改了设置，不刷新； 如果想刷新修改过已挂载的设备，mount -o remount /dev/sdX（挂载点） -L ‘LABEL’： 以卷标指定挂载设备 -U ‘UUID’：以UUID 指定要挂载的设备 -B –bind：绑定目录到另一个目录上， 1例： mount -B /var/ftp/pub /app/apache /app/apache就是显示 /var/ftp/pub目录的东西 -o options：( 挂载文件系统的选项) ，多个选项使用逗号分隔 async（defaults)，sync 异步，同步，内存更改时，同时写磁盘（可以用于重要数据） atime(defaults),noatime 是否在读访问时更新atime diratime(defaults),nodiratime 目录的访问时间戳 auto(defaults)/noauto 写在/etc/fstab当中的分区，是否在mount -a时被挂载 exec(defatuls)/noexec 在该分区所挂载的目录中的脚本是否可以执行。 dev(defaults)/nodev：是否支持在此文件系统上使用设备文件 suid(defaults)/nosuid：是否支持suid和sgid权限 ro：只读 rw：读写(defaults) nouser(defaults)/user：是否允许普通用户挂载此设备，默认管理员才能挂载 acl（centos 7）/^acl（centos 6以下）：启用/禁用此文件系统上的acl功能 ​ defaults：相当于rw, suid, dev, exec, auto, nouser, async -o remount,选项：重新挂载，修改功能选项（和/etc/fstab选项冲突，则覆盖，不冲突就增加） 1例：mount -o remount,ro /dev/sdb1 umount 卸载 卸载时，若有正在进行的进程，不能卸载 查看正在访问指定文件系统的进程： lsof 设备或挂载点都可以 fuser -v 挂载点 终止所有在正访问指定的文件系统的进程： fuser -km 设备或挂载点都可以 终止完所有进程就可以卸载： umount DEVICE /etc/fstab 文件挂载配置文件（1）/etc/fstab 每行定义一个要挂载的文件系统 mount -a 自动挂载/etc/fstab文件没有挂载的设备，不管已挂载过的设备 如果想刷新修改过已挂载的设备，mount -o remount /dev/sdX（或挂载点） （2）格式（6列）： 要挂载的设备或伪文件系统：设备名称，LABEL，UUID，伪文件系统名称 挂载点（扩展为swap） 文件系统类型（auto 寻找默认的）， 普通设备挂载：ext#/xfs 等文件系统类型 交换分区 swap：swap 网络挂载地址 linux之间：nfs，windos挂载：cifs 光盘 iso9660，文件 cifs 挂载选项：defaults 有需要的功能可以添加，不能为空 转储频率： 0：（不做备份 ）1：（每天转储） 2：（每隔一天转储） 开机时自检顺序：（非0），允许的数字是0, 1, 和2（如果开机系统自检不过，就无法正常开机） ​ 0：不自检 ​ 1：首先自检；一般只有rootfs才用 ​ 2：非rootfs使用 （3）如果设备不小心被破坏，开机自检不过，无法正常启用，该怎么办？ 原理很简单，只需要修复一下文件系统就好了，（如果不能修复，可以去/etc/fstab中把自检改为0）具体操作如下： ① 手动破坏设备 dd if=/dev/zero of=/dev/sdc1 bs=1 count=2048 ② 开机过程，遇到错误提示 ③ 进入shell 操作，进行修复 （4）实验：迁移/home 家目录，从 / 下移到另一个磁盘，如/dev/sda6 ① init 1 进入单用户模式，防止自己在迁移时，其他用户进行操作，导致迁移后缺失东西。 ② 分区 /dev/sda6 fdisk ③ 文件系统格式化 mkfs.ext4 /dev/sda6 ④ 挂载在临时目录上/mnt ，把/home 下东西cp -a 到/mnt 目录 ⑤ 把现有/home 东西移走，卸载 /mnt ，把/dev/sda6 挂到 /home 下，并写入/etc/fstab，开机自动挂载。 1UUID=328a3f17-3e4e-426d-9538-c44be3e6465b /home ext4 defaults 0 2 ⑥ reboot或init 5 完成/home 搬迁]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
        <tag>文件系统</tag>
        <tag>分区</tag>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件包管理]]></title>
    <url>%2F2018%2F04%2F29%2F%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[静态和动态链接&ensp;&ensp;&ensp;&ensp;链接主要作用是吧各个模块之间互相引用的部分处理好，使得各个模块之间能够正确的链接，分为静态和动态 静态链接 ​ 把程序对应的依赖库复制一份到包 ​ 以.a为后缀 ​ 嵌入程序包 ​ 升级难 需重新编译 ​ 占用空间多 迁移容易 动态链接 只把依赖加做一个动态链接 以.so为后缀 连接指向 占用空间少 升级方便 若一个库被删，那么所有依赖此库的命令都受影响（使用相对较多） 软件包包命名和工具 源代码： name-VERSION.tar.gz|bz2|xz rpm包命名方式 name-VERSION-release.arch.rpm 例 bash-4.2.46-19.e17.x86_64.rpm 包：分类和拆包 1234Application-VERSION-ARCH.rpm 主包Application-devel-VERSION-ARCH.rpm 开发子包Application-utils-VERSION-ARHC.rpm 其它子包Application-libs-VERSION-ARHC.rpm 其它子包 包之间：可能存在依赖关系，甚至循环依赖 解决依赖包管理工具： yum： rpm包管理器的前端工具 apt-get： deb包管理器前端工具 zypper: suse上的rpm前端管理工具 dnf: Fedora 18+ rpm包管理器前端管理工具 库文件查看二进制程序所依赖的库文件 1ldd /PATH/TO/BINARY_FILE 管理及查看本机装载的库文件 1234567ldconfig 加载库文件/sbin/ldconfig -p 显示本机已经缓存的所有可用库文件名及文件路径映射关系/etc/ld.so.conf/etc/ld.so.conf.d/*.conf 配置文件/etc/ld.so.cache 缓存文件 包管理器&ensp;&ensp;&ensp;&ensp;功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件，从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作 包文件组成 (每个包独有) RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等 安装或卸载时运行的脚本 数据库(公共)： /var/lib/rpm 程序包名称及版本 依赖关系 功能说明 包安装后生成的各文件路径及校验码信息 程序包的来源管理程序包的方式 使用包管理器： rpm 使用前端工具： yum, dnf 获取程序包的途径 系统发版的光盘或官方的服务器 CentOS镜像： https://www.centos.org/download/ http://mirrors.aliyun.com http://mirrors.aliyun.com http://mirrors.aliyun.com 项目官方站点 第三方组织 Fedora-EPELExtra Packages for Enterprise LinuxRpmforge:RHEL推荐，包很全搜索引擎：http://pkgs.org http://rpmfind.net http://rpm.pbone.net https://sourceforge.net/ 自己制作 注意：第三方包建议要检查其合法性包括来源合法性,程序包的完整性 RPM包管理器包安装1rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE… -i 安装选项​ -v 显示过程​ -h 以#显示程序包管理执行进度[install-options] –test 测试安装，但不真正执行安装，即dry run模式 操作走了一次但没装 1例：rpm -i --test vsftab-2* –nodeps 忽略依赖关系 1例：rpm -ivh httpd* --nodeps 能安装但是后期可能不能用 –replacepkgs | replacefiles 若删掉了包中的文件重新装包系统提示已经存在，此时可用此命令 1例：rpm -ivh --replacepkgs tree* replacefiles替代文件 即安装两个包，有同一个相同文件同时写入同一路径下 ​ 此时系统提示不能安装便可用此选项强制安装并覆盖 –nosignature: 不检查来源合法性 –nodigest：不检查包完整性 –noscripts：不执行程序包脚本 %pre: 安装前脚本； –nopre %post: 安装后脚本； –nopost %preun: 卸载前脚本； –nopreun %postun: 卸载后脚本； –nopostun rpm -ivh name1 name2… 一次安装多个包 rpm -V packagesname 查看包属性的变化 包升级（不建议使用）12rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE…rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE… upgrade：安装有旧版程序包，则“升级” 如果不存在旧版程序包，则“安装” freshen：安装有旧版程序包，则“升级” 如果不存在旧版程序包，则不执行升级操作 12rpm -Uvh PACKAGE_FILE …rpm -Fvh PACKAGE_FILE … ​ –oldpackage 降级 ​ –force 强制安装 升级注意项 不要对内核做升级操作； Linux支持多内核版本并存，因此，对直接安装新版本内核 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名(FILENAME.rpmnew)后保留 包查询1rpm &#123;-q|--query&#125; [select-options][query-options] [select-options] -a 所有包 -f 查看指定的文件由哪个程序包安装生成 配合-P使用 后面跟磁盘上的某个文件（也可路径） -p rpmfile 针对尚未安装的程序包文件做查询操作 后面跟文件名（包的完整名）而不是包名 –whatprovides CAPABILITY 查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY 查询指定的CAPABILITY（相当于关键字）被哪个包所依赖 rpm2cpio 包文件|cpio –itv 预览包内文件 相当于把rpm包转化成cpio格式 rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 [query-options] –changelog：查询rpm包的信息变化的过程 -c: 查询程序的配置文件 -d: 查询程序的文档 -i: information -l: 查看指定的程序包安装后生成的所有文件 –scripts：程序包自带的脚本 –provides: 列出指定程序包所提供的CAPABILITY（能力） -R: 查询指定的程序包所依赖的CAPABILITY 例： 12rpm -ql tree 查询tree包下的文件rpm -qR tree 查询tree所依赖的能力 包卸载1rpm &#123;-e|--erase&#125;[--allmatches][–-nodeps][–-noscripts][–-notriggers][–-test] PACKAGE_NAME … ​ -e 卸载 后面直接跟包名就可以不用写完整的名字 ​ –allmatches 若一个包有多个版本使用此选项可将全部卸载 包校验1rpm &#123;-V|--verify&#125; [select-options][verify-options]检查包的属性变化 后面跟包名 S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P capabilities differ 导入所需要公钥123456789rpm -qa "gpg-pubkey*"rpm -K|checksig rpmfile 检查包的完整性和签名（若显示not ok）则此文件存在一定的风险建议不装若执行-K检查命令则必先执行以下命令rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6或 rpm --import /run/media/root/centos\7\x86_64/RPM-GPG-Centos-6rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7或 rpm --import /run/media/root/centos\7\x86_64/RPM-GPG-KEY-centos-7 rpm数据库 数据库重建 ​ /var/lib/rpm 1rpm &#123;--initdb|--rebuilddb&#125; ​ initdb: 初始化 如果事先不存在数据库，则新建之;否则，不执行任何操作 ​ rebuilddb：重建已安装的包头的数据库索引目录 YUM&ensp;&ensp;&ensp;&ensp;yum(Yellow dog Updater,Modified)主要的功能是方便添加、删除和更新rpm软件包。可以解决软件包依存问题，更便于管理大量的系统更新问题。它可以同时配置多个仓库或叫资源库(repository)，就是存放更新和依存的软件包的地方。 yum的由来&ensp;&ensp;&ensp;&ensp;为了解决程序间的依赖关系，RedHat曾推出了一款名为update的工具。这款工具虽然达到了目的，但用户体验并不是很好。后来一个基于RedHat的二次发行版yellowdog，由此也推出了一个工具：yellowdog update modifier，简写为yum. 由于比update好用，于是便流行开来。后来导致RedHat也弃update不用而使用yum yum的特性&ensp;&ensp;&ensp;&ensp;yum相对于rpm来说：rpm为基础包管理器，yum则是rpm的前端工具。yum无法独立存在系统,不允许有两个yum命令同时运行，如果有两个，第二次运行时会报错。这是为了防止yum之间的冲突 yum的配置文件/etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置 yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据文件（放置于特定目录repodata下）文件服务器： 1234http://https://ftp://file:// yum客户端配置文件：12345678910111213vim /etc/yum.conf：为所有仓库提供公共配置[main]语句块名称cachedir=/var/cache/yum/$basearch/$releasever #缓存文件夹keepcache=0 #1表示rpm包保存 0表示不保存debuglevel=2 #调试一般不用管logfile=/var/log/yum.log #yum的日志exactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5 #同时可装5个包bugtracker_url=http://bugs.centos.org/set_project.php?project_id=19&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-release /etc/yum.repos.d/*.repo：为仓库的指向提供配置 后缀必须为.repo 仓库指向的定义：1234567891011[repositoryID] #第一行用一个单词不允许出现空格名字可以随意name=Some name for this repository #描述语句baseurl=url://path/to/repository/第二行路径 #repodata的父目录就是路径enabled=&#123;1|0&#125; #0表示禁用1表示启用gpgcheck=&#123;1|0&#125; #第三行是否检查包的完整性0表示不检查gpgkey=URLenablegroups=&#123;1|0&#125;failovermethod=&#123;roundrobin|priority&#125;# roundrobin：意为随机挑选，默认值# priority:按顺序访问cost= 默认为1000 yum源阿里云repo文件 CentOS系统的yum源 阿里云 清华大学 EPEL的yum源 阿里云 yum 命令显示仓库列表1yum repolist [all|enabled|disabled] 显示程序包123yum listyum list [all | glob_exp1] [glob_exp2] […]yum list &#123;available|installed|updates&#125; [glob_exp1] […] 安装程序包12yum install package1 [package2] […]yum reinstall package1 [package2] […] (重新安装) 升级程序包12yum update [package1] [package2] […]yum downgrade package1 [package2] […] (降级) 检查可用升级1yum check-update 卸载程序包1yum remove | erase package1 [package2] […] 查看程序包information1yum info […] 查看指定的特性(可以是某文件)是由哪个程序包所提供1yum provides | whatprovides feature1 [feature2] […] 清理本地缓存12清除/var/cache/yum/$basearch/$releasever缓存yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] 构建缓存1yum makecache 搜索:以指定的关键字搜索程序包名及summary信息1yum search string1 [string2] […] 查看指定包所依赖的capabilities1yum deplist package1 [package2] […] 查看yum事务历史123456yum history [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]yum historyyum history info 6yum history undo 6 日志1/var/log/yum.log 安装及升级本地程序包1234yum localinstall rpmfile1 [rpmfile2] […](用install替代)yum localupdate rpmfile1 [rpmfile2] […](用update替代) 包组管理的相关命令12345yum groupinstall group1 [group2] […]yum groupupdate group1 [group2] […]yum grouplist [hidden] [groupwildcard] […]yum groupremove group1 [group2] […]yum groupinfo group1 […] yum的命令行选项： –nogpgcheck：禁止进行gpg check -y: 自动回答为“yes” -q：静默模式 –disablerepo=repoidglob：临时禁用此处指定的repo –enablerepo=repoidglob：临时启用此处指定的repo –noplugins：禁用所有插件 系统光盘作为本地yum仓库(1) 挂载光盘至某目录，例如/mnt/cdrom1mount /dev/cdrom /mnt/cdrom (2) 创建配置文件12345[base]name=base.repobaseurl=file:///mnt/cdromgpgcheck=0enabled=1]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>rpm</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本三剑客之grep]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bgrep%2F</url>
    <content type="text"><![CDATA[grep and Regular Expressions grep&ensp;&ensp;&ensp;&ensp;grep: Global search REgular expression and Print out the line,是一款文本过滤工具。&ensp;&ensp;&ensp;&ensp;作用：文本搜索工具，根据用户指定的“模式”对目标文本逐行进行匹配检查；打印匹配到的行。&ensp;&ensp;&ensp;&ensp;模式：由正则表达式字符及文本字符所编写的过滤条件。&ensp;&ensp;&ensp;&ensp;正则表达式REGEXP： Regular Expressions，由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能。 正则表达式分两类： 基本正则表达式： BRE 扩展正则表达式： EREgrep工具支持基本正则表达式，egrep工具支持扩展的正则表达式，并且grep -E = egrep. grep语法grep [OPTIONS] PATTERN [FILE…] -v: 显示不被pattern匹配到的行 -i: 忽略字符大小写 -n： 显示匹配的行号 -c: 统计匹配的行数 -o: 仅显示匹配到的字符串 -q: 静默模式，不输出任何信息 -A #: after, 后#行 -B #: before, 前#行 -C #： context, 前后各#行 -e：实现多个选项间的逻辑or关系 -w：匹配整个单词 -E：使用ERE -F：相当于fgrep，不支持正则表达式 -f file: 根据模式文件处理 基本正则表达式元字符字符匹配 . &ensp; &ensp;&ensp;&ensp;匹配任意单个字符 1234[root@localhost data]#grep "r..t" /etc/passwd root:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologin [] &ensp; &ensp;&ensp;匹配指定范围内的任意单个字符，示例:[wang] [0-9] [a-z] [a-zA-Z] [^] &ensp;&ensp;匹配指定范围外的任意单个字符 [:alnum:] 字母和数字 [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:lower:] 小写字母,亦即 a-z [:upper:] 大写字母,亦即 A-Z [:blank:] 空白字符（空格和制表符） [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） [:cntrl:] 不可打印的控制字符（退格、删除、警铃…） [:digit:] 十进制数字 [:xdigit:] 十六进制数字 [:graph:] 可打印的非空白字符 [:print:] 可打印字符 [:punct:] 标点符号例 12345[root@localhost data]#ifconfig ens33 | grep netmask | grep "[[:digit:]]." inet 192.168.183.132 netmask 255.255.255.0 broadcast 192.168.183.255等价于[root@localhost data]#ifconfig ens33 | grep netmask | grep "[0-9]." inet 192.168.183.132 netmask 255.255.255.0 broadcast 192.168.183.255 次数匹配用在要指定次数的字符后面，用于指定前面的字符要出现的次数123456789* 匹配前面的字符任意次，包括0次 贪婪模式：尽可能长的匹配.默认正则表达式为贪婪模式 .* 任意长度的任意字符 \? 匹配其前面的字符0或1次 \+ 匹配其前面的字符至少1次 \&#123;n\&#125; 匹配前面的字符n次 \&#123;m,n\&#125; 匹配前面的字符至少m次，至多n次 \&#123;,n\&#125; 匹配前面的字符至多n次 \&#123;n,\&#125; 匹配前面的字符至少n次正则表达式 例:12345678910111213141516[root@localhost data]#ifconfig ens33 | grep "[0-9]\&#123;1,3\&#125;" ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.183.132 netmask 255.255.255.0 broadcast 192.168.183.255 inet6 fe80::bf41:5d04:86fa:37c9 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:30:79:38 txqueuelen 1000 (Ethernet) RX packets 7676 bytes 850492 (830.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 6678 bytes 2198697 (2.0 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0例:只显示ifconfig ens33 的ip[root@localhost data]#ifconfig ens33 | grep -o "[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;"192.168.183.132255.255.255.0192.168.183.255 位置锚定定位出现的位置12345678* ^ 行首锚定，用于模式的最左侧 * $ 行尾锚定，用于模式的最右侧 * ^PATTERN$ 用于模式匹配整行 * ^$ 空行 * ^[[:space:]]*$ 空白行* \&lt; 或 \b 词首锚定，用于单词模式的左侧 * \&gt; 或 \b 词尾锚定，用于单词模式的右侧 * \&lt;PATTERN\&gt; 匹配整个单词正则表达式 1234567例:只显示/etc/fstab非空的行[root@localhost data]#cat /etc/fstab | grep -v "^#" | grep -v "^$"UUID=d33ffb51-004a-4c4d-ac00-c40b9e2c2920 / xfs defaults 0 0UUID=7d1b5c8d-8054-4496-befe-267963e07605 /boot xfs defaults 0 0UUID=7556e4a8-128e-457f-99f7-3f1ccf517952 /data xfs defaults 0 0UUID=152e9015-e93a-44f9-8c7d-65fe67fb5201 swap swap defaults 0 0 12345显示以root为单词词首的行[root@localhost ~]#grep "\&lt;root" /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin _分组_\(\) 将一个或多个字符捆绑在一起，当作一个整体处理，如： \(root\)\+ 分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, … \1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 123\(string1\+\(string2\)*\)\1 ： string1\+\(string2\)*\2 ： string2 后向引用：引用前面的分组括号中的模式所匹配字符(结果)， 而非模式本身 12345[root@localhost ~]#cat f1123ab123xxy123234xxx567[root@localhost ~]#cat f1 | grep "\([0-9]\)\&#123;3\&#125;.*\1"123ab123xxy123 或者：\|示例： a\|b: a或b C\|cat: C或cat \(C\|c\)at:Cat或cat 扩展的正则表达式egrep [OPTIONS] PATTERN [FILE…] 字符匹配 . 任意单个字符 [] 指定范围的字符 [^] 不在指定范围的字符基本和正则表达式相同 次数匹配12345678* 匹配前面的字符任意次，包括0次 .* 任意长度的任意字符 ? 匹配其前面的字符0或1次 + 匹配其前面的字符至少1次 &#123;n&#125; 匹配前面的字符n次 &#123;m,n&#125; 匹配前面的字符至少m次，至多n次 &#123;,n&#125; 匹配前面的字符至多n次 &#123;n,&#125; 匹配前面的字符至少n次正则表达式 位置锚定扩展正则表达式的位置锚定和基本正则表达式相同。 _分组_( )的内容不需要用\转义 或者：|示例： a|b: a或b C|cat: C或cat (C|c)at:Cat或cat 练习 利用df和grep，取出磁盘各分区利用率，并从大到小排序1df | grep /dev/sd | grep -o "[0-9]\+%" | grep -o "[0-9]\+" |sort -nr 1df | grep -E /dev/sd | grep -oE "[0-9]+%" | grep -Eo "[0-9]+" |sort -nr 显示ifconfig命令结果中所有IPv4地址1ifconfig ens33 | grep -o "\&lt;\(\([0-1][0-9]\?\&#123;2\&#125;\|2[0-4][0-9]\|25[0-5]\)\.\)\&#123;3\&#125;\([0-1][0-9]\?\&#123;2\&#125;\|2[0-4][0-9]\|25[0-5]\)\&gt;" 1ifconfig ens33 | egrep -o "\&lt;(([0-1][0-9]?&#123;2&#125;|2[0-4][0-9]|25[0-5])\.)&#123;3&#125;([0-1][0-9]?&#123;2&#125;|2[0-4][0-9]|25[0-5])\&gt;" 找出/etc/passwd用户名和shell同名的行1grep "^\([[:alnum:]]\&#123;1,\&#125;\):.*\1$" /etc/passwd 1grep -E "^([[:alnum:]]&#123;1,&#125;):.*\1$" /etc/passwd 手机号1grep -o "1[34578][0-9]\&#123;9\&#125;" 1grep -Eo "1[34578][0-9]&#123;9&#125;" 使用egrep取出/etc/rc.d/init.d/functions中其基名 1echo /etc/rc.d/init.d/functions/ | grep -o "[^/]\+/\?$" | grep -o ".*[^/]" 1echo /etc/rc.d/init.d/functions/ | egrep -o "[^/]+/?$" | egrep -o ".*[^/]" 显示CentOS7的/etc/grub2.cfg文件中，至少以一个空白字符开头的且后面有非空白字符的行1grep "^[[:space:]]\+[^[:space:]]" /etc/grub2.cfg 1grep -E "^[[:space:]]+[^[:space:]]" /etc/grub2.cfg]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文本工具</tag>
        <tag>正则</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅议linux中的硬链接和软链接]]></title>
    <url>%2F2018%2F02%2F10%2F%E6%B5%85%E8%AE%AElinux%E4%B8%AD%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[链接文件的概念&ensp;&ensp;&ensp;&ensp;Linux中的链接文件就相当于是Windows中的快捷方式，通过链接文件可以访问到链接指向的源文件。但是Linux下的链接文件和Windows中的快捷方式还是有一定的区别。Linux中有两种链接文件分别为硬链接和软链接（也称为符号链接）。在介绍链接文件之前先要介绍一下Linux文件系统中的inode。 节点的概念&ensp;&ensp;&ensp;&ensp;我们都知道文件数据都是储存在硬盘的”块”区域中。那么很显然，我们还必须找一块区域储存文件的元数据信息，比如文件的创建者、文件的创建时间、文件的大小等等，这种存储文件元数据信息的区域就叫做inode，中文译名为”索引节点” Inode（索引节点）包含有关文件的信息（元数据），具体有如下内容： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 我们可以使用stat命令来查看某个文件的inode的信息：12345678910[root@localhost ~]#stat /data/f1 File: ‘/data/f1’ Size: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 803h/2051d Inode: 67 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Context: unconfined_u:object_r:etc_runtime_t:s0Access: 2018-09-29 10:34:06.156131723 +0800Modify: 2018-09-29 10:34:06.156131723 +0800Change: 2018-09-29 10:34:06.156131723 +0800 Birth: - 注意：文件名是不存在inode中的！！! 查看每个硬盘分区的inode总数和使用的数量，可以用df -i 来查看:1234567891011[root@localhost ~]#df -iFilesystem Inodes IUsed IFree IUse% Mounted on/dev/sda2 26214400 122731 26091669 1% /devtmpfs 229181 397 228784 1% /devtmpfs 233163 1 233162 1% /dev/shmtmpfs 233163 881 232282 1% /runtmpfs 233163 16 233147 1% /sys/fs/cgroup/dev/sda1 524288 327 523961 1% /boot/dev/sda3 15728640 4 15728636 1% /datatmpfs 233163 9 233154 1% /run/user/42tmpfs 233163 1 233162 1% /run/user/0 空间满了和inode用光了都报No space left on device 下图就是磁盘空间占满了提示：12345678910111213[root@localhost data]#dd if=/dev/zero of=/boot/bigfile bs=1M count=860dd: error writing ‘/boot/bigfile’: No space left on device850+0 records in849+0 records out890306560 bytes (890 MB) copied, 2.25818 s, 394 MB/s[root@localhost data]#df -h /dev/sda1Filesystem Size Used Avail Use% Mounted on/dev/sda1 1014M 1014M 336K 100% /boot[root@localhost data]#df -i /dev/sda1 Filesystem Inodes IUsed IFree IUse% Mounted on/dev/sda1 1184 328 856 28% /boot 下图就是inode用光的提示：12345678[root@localhost dir1]#df -i /dev/sda1Filesystem Inodes IUsed IFree IUse% Mounted on/dev/sda1 524288 524288 0 100% /boot也会报touch: cannot touch ‘f524284’: No space left on devicetouch: cannot touch ‘f524285’: No space left on devicetouch: cannot touch ‘f524286’: No space left on device 每个inode都有一个号码，操作系统用inode号码来识别不同的文件。对于系统来说，文件名只是inode号码便于识别的别称和绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件所在的block，读出数据。 使用ls -i命令，可以看出文件名对应的inode号码：12[root@localhost ~]#ls -i /data/f167 /data/f1 硬链接一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Linux系统允许多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名;删除一个文件名，不影响另一个文件名的访问。这种情况就被称为:硬链接”(hard link)。可以通过ln命令来创建硬链接：&ensp;&ensp;&ensp;&ensp;ln&ensp; 源文件&ensp; 目标文件 12345678910[root@localhost data]#ls2.txt f1[root@localhost data]#ln 2.txt 22.txt[root@localhost data]#ls22.txt 2.txt f1[root@localhost data]#ll -itotal 868 -rw-r--r--. 2 root root 22 Sep 25 15:41 22.txt68 -rw-r--r--. 2 root root 22 Sep 25 15:41 2.txt67 -rw-r--r--. 1 root root 0 Sep 25 14:16 f1 创建文件时链接数递增 123456[root@localhost data]#ll -i f167 -rw-r--r--. 1 root root 0 Sep 29 10:34 f1[root@localhost data]#ln f1 f11[root@localhost data]#ll -i f1 f1167 -rw-r--r--. 2 root root 0 Sep 29 10:34 f167 -rw-r--r--. 2 root root 0 Sep 29 10:34 f11 不能跨越驱动器或分区 12[root@localhost data]#ln /data/f2 /root/f22ln: failed to create hard link ‘/root/f22’ =&gt; ‘/data/f2’: Invalid cross-device link 不支持文件夹 12[root@localhost data]#ln dir1 dir11ln: ‘dir1’: hard link not allowed for directory 软链接除了硬链接以外，还有一种特殊情况。文件A和文件B的incode号码虽然不一样，但是文件A的内容就是文件B的路径。读取文件A时系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时文件A就称为文件B的”软链接”(soft link)或者”符号链接”(symbolic link)可以通过ln -s命令来创建软链接：&ensp;&ensp;&ensp;&ensp;ln -s &ensp;源文件或目录&ensp; 目标文件或目录 123456789101112131415[root@localhost data]#lltotal 8-rw-r--r--. 2 root root 22 Sep 25 15:41 22.txt-rw-r--r--. 2 root root 22 Sep 25 15:41 2.txt-rw-r--r--. 1 root root 0 Sep 25 14:16 f1[root@localhost data]#ln -s 2.txt 2.txt-link[root@localhost data]#lltotal 8-rw-r--r--. 2 root root 22 Sep 25 15:41 22.txt-rw-r--r--. 2 root root 22 Sep 25 15:41 2.txtlrwxrwxrwx. 1 root root 5 Sep 25 16:01 2.txt-link -&gt; 2.txt[root@localhost data]#cat 2.txt学习使我快乐！[root@localhost data]#cat 2.txt-link学习使我快乐！ 指向的是另一个文件的路径其大小为指向的路径字符串的长度不增加或减少目标文件inode的引用计数 硬链接和软链接的区别 是不是同一个文件? 这是根本的原因 硬链接本质上是一个文件，只是有多个名字。 软链接不是同一个文件 能不能跨分区？ 硬链接不能跨分区 软链接可以跨分区 链接数是否增长？ 硬链接的链接数会增加 软链接的链接数不会增加 inode Number 是否相同？ 硬链接的inode number完全一样 软链接的inode number不一样 原始文件删除，链接文件可否访问？ 硬链接：原始文件与链接文件是平级关系，原始文件删除，链接文件可以继续访问。 软链接：原始文件删除，软链接就找不到路径，无法访问 大小是否一样 硬链接的大小就是存储原始文件的大小 软链接的大小就是它指向路径的大小 支持目录？ 硬链接不支持目录 软链接支持目录 相对路径？ 硬链接：相对路径是相对当前目录的路径 软链接：相对路径是相对软链接的路径]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Inode</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux用户、组和权限管理]]></title>
    <url>%2F2018%2F02%2F03%2FLinux%E7%94%A8%E6%88%B7%E3%80%81%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux 用户和用户组基础概念&ensp;&ensp;&ensp;&ensp; Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户、用户组的类别： 用户user Linux用户： Username/UID 管理员： root, 0普通用户： 1-60000 自动分配 系统用户： 1-499, 1-999 （CentOS7） 对守护进程获取资源进行权限分配登录用户： 500+, 1000+（CentOS7）通过交互式方式登录 组group Linux组： Groupname/GID 管理员组： root, 0普通组： 系统组： 1-499, 1-999（centos7）普通组： 500+, 1000+（centos7） 对于一个用户而言可以有不同的组，分别称为用户的基本组（主组）和附加组；基本组组名与用户名相同，且仅包含一个用户，也叫私有组。基本组以外的的组属于用户的附加组。 判断用户和组是不是管理员，不是根据名字叫root来判断的，而是根据UID和GID是不是等于0来判断的。等于0则为管理员，否则则不是。 用户配置文件 用户及其属性信息(名称、 UID、主组ID等）：/etc/passwd 组及其属性信息：/etc/group 用户密码及相关属性：/etc/shadow 组密码及相关属性：/etc/gshadow /etc/passwd123456[root@localhost ~]#cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin /etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段： 用户名:口令:UID:GID:注释性描述:主目录:登录Shell类型 系统中有一类用户称为系统用户，这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求.系统用户含义:bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用 /etc/group当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。123456789[root@localhost ~]#cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:tty:x:5:disk:x:6:lp:x:7: 此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 组名:是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。口令:字段存放的是用户组加密后的口令字。组标识号:与用户标识号类似，也是一个整数，被系统内部用来标识组。组内用户列表:是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组 /etc/shadow/etc/shadow文件用于单独存放加密后的口令字，只有超级用户才拥有该文件读权限注意：/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生123456[root@localhost ~]#cat /etc/shadowroot:$6$9T5n/VcnCXrseL/f$Nqs3zA.hfJPXIrNtuiyUD9Ps6s.aGC.XYPrABjgPPABgvRIyMntuEkw2All7VhDQd5XM3AiN2RqAdwuoUfJ0K1::0:99999:7:::bin:*:17632:0:99999:7:::daemon:*:17632:0:99999:7:::adm:*:17632:0:99999:7:::lp:*:17632:0:99999:7::: 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 登录名:/etc/passwd文件中的登录名相一致的用户账号口令:字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；最后一次修改时间:表示的是从某个时刻起，到用户最后一次修改口令时的天数最小时间间隔:指的是两次修改口令之间所需的最小天数最大时间间隔:指的是口令保持有效的最大天数警告时间:字段表示的是从系统开始警告用户到用户密码正式失效之间的天数不活动时间:表示的是用户没有登录活动但账号仍能保持有效的最大天数失效时间:字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 /etc/gshadow123456789[root@localhost ~]#cat /etc/gshadowroot:::bin:::daemon:::sys:::adm:::tty:::disk:::lp::: 它的文件格式与/etc/group类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：群组名称：就是群组名称群组密码：组管理员列表：组管理员的列表，更改组密码和成员以当前组为附加组的用户列表： (分隔符为逗号) 用户和组的管理命令用户管理命令 useradd(创建用户)usermod(修改用户)userdel(删除用户) 组管理命令 groupadd(创建组)groupmod(修改组)groupdel(删除组) 密码配置命令 passwd(设置用户密码)gpasswd（设置组密码） 用户创建:useradd useradd [options] LOGIN -u UID:用户ID的数字值。此值必须为唯一的，除非使用了-o选项。此值必须非负，默认使用大于等于UID_MIN，且大于任何其他用户ID最小值-o 配合-u 选项，不检查UID的唯一性-g GID：指明用户所属基本组，可为组名，也可以GID-c “COMMENT”：用户的注释信息-d HOME_DIR: 以指定的路径(不存在)为家目录-s SHELL: 指明用户的默认shell程序，可用列表在/etc/shells文件中-G GROUP1[,GROUP2,…]：为用户指明附加组，组须事先存在-N 不创建私用组做主组，使用users组做主组-r 创建系统用户 CentOS 6: ID&lt;500， CentOS 7: ID&lt;1000-m 创建家目录，用于系统用户-M 不创建家目录，用于非系统用户 useradd -D：显示创建用户时的默认设置；useradd -D 选项：设置某默认选项； 例1：创建一个用户sam，为sam指定主目录为/usr/sam1useradd -d /usr/sam sam 例2：创建用户gentoo，附加组为bin和root，默认shell为/bin/csh，注释信息为“Gentoo Distribution”1useradd -c "Gentoo Distribution" -G bin,root -s /bin/csh gentoo 例3:新建用户gem，指定该用户的登录Shell是 /bin/sh，指定它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。123groupadd groupgroupadd admuseradd -s /bin/sh -g group –G "adm,root" gem 例4:创建下面的用户、组和组成员关系名字为webs 的组用户nginx 使用webs 作为附属组用户varnish，也使用webs 作为附属组用户mysql，不可交互登录系统，且不是webs 的成员， nginx， varnish，mysql密码都是magedu1234567groupadd websuseradd nginx -G websuseradd varnish -G websuseradd mysql -s /sbin/nologinecho magedu | passwd --stdin nginxecho magedu | passwd --stdin varnishecho magedu | passwd --stdin mysql 用户属性修改:usermod注意：usermod不允许改变正在线上的使用者帐号名称。当usermod改变userID,必须确认这名user没在电脑上执行任何程序 usermod [OPTION] login-u UID: 新UID-g GID: 新主组-G GROUP1[,GROUP2,…[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项-s SHELL：新的默认SHELL-c ‘COMMENT’：新的注释信息-d HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用-m选项-l login_name: 新的名字-L: lock指定用户,在/etc/shadow 密码栏的增加 !-U: unlock指定用户,将 /etc/shadow 密码栏的 ! 拿掉-e YYYY-MM-DD: 指明用户账号过期日期-f INACTIVE: 设定非活动期限 删除用户:userdel userdel [OPTION]… login-r：用户主目录中的文件将随用户主目录和用户邮箱一起删除 创建组:groupadd groupadd [OPTION]… group_name-g GID :指明GID,默认是上一个组的GID+1-r:创建系统组，默认为1-999数字 修改和删除组 组属性修改:groupmod groupmod [OPTION]… group-n group_name: 新名字-g GID: 新的GID 组删除：groupdelgroupdel GROUP passwd：密码设置常用命令以下命令只有root才有权限操作passwd：修改自己的密码passwd username：修改其它用户的密码-d：删除指定用户密码-l： 锁定指定用户-e：强制用户下次登录修改密码-f：强制操作-n mindays：指定最短使用期限-x maxdays： 最大使用期限-w warndays：提前多少天开始警告-i inactivedays：非活动期限–stdin：从标准输入接收用户密码echo “PASSWORD” | passwd –stdin USERNAME​ 更改组密码:gpasswd gpasswd [OPTION] GROUP-a UserName：把用户添加至组中-d UserName：从此组中移除此用户； newgrp命令：登录到一个新组 chage命令：修改用户账号的各种期限；修改账户或口令的期限设定1234561. 口令最短使用期限7天，最长使用期限30天，警告期3天，非活动期3天。 [root@localhost ~]# chage -m7 -M30 -W3 -I3 mageedu 2. 修改口令最近一次修改时间，需转换为设定时间到1970年1月1日的天数 [root@localhost ~]# chage -d16860 mageedu 3. 设置账户过期时间，需转换为设定时间到1970年1月1日的天数。 [root@localhost ~]# chage -E16920 mageedu chsh：更换登入系统时使用的shell, chfn：提供使用者更改个人资讯, finger：使用者查询一些其他使用者的资料, pwck : 检查密码文件的完整性, grpck：检查组文件的完整性 su：切换用户 不读取目标用户的配置文件,不改变当前工作目录（非登录式切换，半切换)su UserName 读取目标用户的配置文件,切换至家目录（登录式切换，完全切换)su - UserName 仅以指定的用户的身份运行此处指定的命令，而不执行真正的身份切换操作su [-] UserName -c ‘COMMAND’注意：root切换至任何其它用户无须认证密码；普通用户切换至其它用户，都需要密码 用户和用户组权限管理12[root@localhost ~]#ll -d /etc # 显示文件名与相关属性命令drwxr-xr-x. 137 root root 12288 Oct 21 09:57 /etc 类型和权限(permission)： 显示格式： 类型和权限 连接数 所有者 用户组 文件大小 修改日期 文件名 权限组合机制：(8bites 二进制) 第二道十个字符：每三个为一组，均为’rwx’三个参数组合rwxrwxrwx每个位置固定不定，若无则为空，用’-‘符号表示 r：readable, 读；w：writable, 写；x：excutable，执行 r=4 w=2 x=1 -=0 文件权限系统主要分为3类用户： 属主：owner,u 属组：group,g 其他：other,o 其与之对应的权限:​ rwx rwx rwx 文件和目录的权限管理： 对于文件的含义: r：可获取文件的数据；可以使用类似于cat命令查看文件内容 w: 可修改文件的数据；可以编或者删除此文件 x：可将此文件运行为进程；可以在命令提示符下当做命令提交给内核运行 对于目录的含义: r：可使用ls命令获取其下的所有文件列表； w: 可修改此目录下的文件列表；即创建或删除文件； x: 可cd至此目录中，且可使用ls -l来获取所有文件的详细属性信息； X: 只针对目录添加x权限，不对目录下的文件添加x权限； 权限管理命令chmod:更改文件目录权限用户类型：u：属主 g：属组 o：其它 a: 所有 chmod [OPTION]… MODE[,MODE]… FILE… 赋权表示法：直接操作一类用户的所有权限位rwx用等号表示：[u|g|o|a]=rwx中的一位或者多位 授权表示法：直接操作一类用户的一个权限位r,w,x用加减号表示：[u|g|o|a][+|-]rwx chmod [OPTION]… OCTAL-MODE FILE…直接使用三位数字的方式给文件目录增加权限，分别表示所有者、所属组、其他人的权限数字的表示方法同上：8bites 二进制表示权限的组合机制r=4 w=2 x=1 三位相加12345[root@CentOS6 data]#ll--w-------. 1 root root 0 Oct 21 20:29 f1[root@CentOS6 data]#chmod 666 f1 #对 (u g o)添加读写权限[root@CentOS6 data]#ll-rw-rw-rw-. 1 root root 0 Oct 21 20:29 f1 chmod [OPTION]… –reference=RFILE FILE… 参照某个文件的权限来进行授权操作123456789[root@CentOS6 data]#ll--w-------. 1 root root 0 Oct 21 20:29 f1-rw-r--r--. 1 root root 0 Oct 21 21:20 f2-rw-r--r--. 1 root root 0 Oct 21 21:20 f3[root@CentOS6 data]#chmod --reference=f1 f2 f3[root@CentOS6 data]#ll--w-------. 1 root root 0 Oct 21 20:29 f1--w-------. 1 root root 0 Oct 21 21:20 f2--w-------. 1 root root 0 Oct 21 21:20 f3 注意：普通用户仅能修改属主为自己的那些文件的权限；root可以更改所有用户 chown:更改文件目录的所有者，也可以更改所属组12345[root@CentOS6 data]#ll f1-rw-rw-rw-. 1 root root 0 Oct 21 20:29 f1[root@CentOS6 data]#chown xie f1[root@CentOS6 data]#ll f1-rw-rw-rw-. 1 xie root 0 Oct 21 20:29 f1 chgrp [OPTION]… GROUPFILE… 更改所属组1234[root@CentOS6 data]#ll f1-rw-rw-rw-. 1 xie root 0 Oct 21 20:29 f1[root@CentOS6 data]#ll f1-rw-rw-rw-. 1 xie rpc 0 Oct 21 20:29 f1 注意： 普通用户是不能更改文件的所有者的 作为普通用户，要想更改文件的所属组： 文件是普通用户它自己的如果要更改的组，普通用户必须在这个组里 umask:文件的权限反向掩码，遮罩码 umask：查看当前umask12[root@localhost ~]#umask0022 系统默认为：0022 表示特殊权限、所有者权限、所有组权限、其他人权限更改默认设置位置：/etc/bashrc 对文件目录的umask操作 文件：666-umask 文件默认不能拥有执行权限;如果减得的结果中有执行权限，则需要将其加1文件夹：777-umask Linux文件系统上的特殊权限SUID功能：继承二进制程序所有者的权限权限设定：chmod u+s file…chmod u-s file…chmod 4### file…1234567891011[root@localhost data]#ll f1-rw-r--r--. 1 root root 595 Oct 14 14:16 f1[root@localhost data]#chmod u+s f1[root@localhost data]#ll f1-rwSr--r--. 1 root root 595 Oct 14 14:16 f1[root@localhost data]#chmod u-s f1[root@localhost data]#ll f1-rw-r--r--. 1 root root 595 Oct 14 14:16 f1[root@localhost data]#chmod 4644 f1[root@localhost data]#ll f1 -rwSr--r--. 1 root root 595 Oct 14 14:16 f1 SUID只对二进制可执行程序有效SUID设置在目录上无意义 SGID 可执行文件上SGID权限功能：继承二进制程序所有组的权限权限设定：chmod g+s file…chmod g-s file…chmod 2### file… 目录上的SGID权限功能：此目录新建的文件继承目录的所属组权限设定：chmod g+s dir…chmod g-s dir…chmod 2### dir… Sticky位功能：作用于目录，此目录的文件只能被所有者或root删除权限设定:chmod o+t dir…chmod o-t dir…chmod 1### dir…12[root@localhost ~]#ll -d /tmpdrwxrwxrwt. 15 root root 4096 Oct 23 18:33 /tmp 权限位映射SUID: user,占据属主的执行权限位s： 属主拥有x权限S：属主没有x权限SGID: group,占据属组的执行权限位s： group拥有x权限S： group没有x权限Sticky: other,占据other的执行权限位t： other拥有x权限T： other没有x权限 访问控制列表ACL： Access Control List，实现灵活的权限管理除了文件的所有者，所属组和其它人，可以对更多的用户设置权限CentOS7 默认创建的xfs和ext4文件系统具有ACL功能CentOS7 之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加tune2fs –o acl /dev/sdb1mount –o acl /dev/sdb1 /mnt/testACL生效顺序：所有者，自定义用户，自定义组，其他人 常见的一些命令setfacl -m u:username:rwx file 为用户的文件赋予访问权限rwxsetfacl -m g:groupname:rw file 为组的文件赋予访问权限rwxgetfacl filename 查看设置的acl权限setfacl -b filename 清空acl权限setfacl -k dir 删除默认ACL权限123456789101112131415161718192021222324[root@localhost data]#ll f1-rw-r--r--. 1 root root 595 Oct 14 14:16 f1[root@localhost data]#setfacl -m u:xie:rw f1[root@localhost data]#ll f1-rw-rw-r--+ 1 root root 595 Oct 14 14:16 f1 # +代表有acl权限[root@localhost data]#getfacl f1# file: f1# owner: root# group: rootuser::rw-user:xie:rw-group::r--mask::rw-other::r--[root@localhost data]#setfacl -b f1[root@localhost data]#ll f1-rw-r--r--. 1 root root 595 Oct 14 14:16 f1[root@localhost data]#getfacl f1# file: f1# owner: root# group: rootuser::rw-group::r--other::r-- 练习 当用户docker对/testdir 目录无执行权限时，意味着无法做哪些操作？答:无法cd至此目录中；无法查看目录的详细属性；无法查看文件的内容； 当用户mongodb对/testdir 目录无读权限时，意味着无法做哪些操作？答:可使用ls命令获取其下的所有文件列表 当用户redis 对/testdir 目录无写权限时，该目录下的只读文件file1是否可修改和删除？答:不行，文件能不能删除由目录的权限决定的。（rw） 当用户zabbix对/testdir 目录有写和执行权限时，该目录下的只读文件file1是否可修改和删除？答:可以 复制/etc/fstab文件到/var/tmp下，设置文件所有者为tomcat读写权限，所属组为apps组有读写权限，其他人无权限 123456useradd tomcatgroupadd appscp /etc/fstab /var/tmpchown tomcat /var/tmp/fstabchgrp apps /var/tmp/fstabchmod 660 /var/tmp/fstab 误删除了用户git的家目录，请重建并恢复该用户家目录及相应的权限属性 123456useradd gitrm -rf /home/gitmkdir /home/gitcp -a /etc/skel/.[^.]* /home/gitchown -R git.git /home/gitchmod 700 /home/git 在/testdir/dir里创建的新文件自动属于webs组，组apps的成员如：tomcat能对这些新文件有读写权限，组dbs的成员如： mysql只能对新文件有读权限，其它用户（不属于webs,apps,dbs）不能访问这个文件夹 1234567891011mkdir -p /testdir/dirgroupadd webschgrp webs /testdir/dirchmod g+s /testdir/dir groupadd apps groupadd dbsuseradd -G apps tomcatuseradd -G dbs mysqlsetfacl -m g:apps:rw /testdir/dir/setfacl -m g:dbs:r /testdir/dir/chmod o= /testdir/dir 备份/testdir/dir里所有文件的ACL权限到/root/acl.txt中，清除/testdir/dir中所有ACL权限，最后还原ACL权限 123getfacl -R /testdir/dir &gt; /root/acl.txt setfacl -b /testdir/dirsetfacl -R –set-file=acl.txt /testdir/dir]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>user</tag>
        <tag>group</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准IO和管道]]></title>
    <url>%2F2018%2F01%2F05%2F%E7%AE%A1%E9%81%93%E5%92%8C%E6%A0%87%E5%87%86IO%2F</url>
    <content type="text"><![CDATA[标准输入和输出程序：指令+数据 读入数据：Input 输出数据：Output 打开的文件都有一个fd: file descriptor (文件描述符)123456[root@centos7 ~]#ll /proc/$$/fdtotal 0lrwx------ 1 root root 64 Oct 28 14:43 0 -&gt; /dev/pts/2lrwx------ 1 root root 64 Oct 28 14:43 1 -&gt; /dev/pts/2lrwx------ 1 root root 64 Oct 28 14:43 2 -&gt; /dev/pts/2lrwx------ 1 root root 64 Oct 28 19:33 255 -&gt; /dev/pts/2 Linux给程序提供三种I/O设备标准输入（STDIN） －0 默认接受来自键盘的输入标准输出（STDOUT）－1 默认输出到终端窗口标准错误（STDERR）－2 默认输出到终端窗口 I/O重定向改变文件保存的默认位置 标准输出和错误输出重定向格式: 命令 操作符号 文件名 支持的操作符号包括:> 把STDOUT重定向到文件12345[root@CentOS6 ~]#ls /datalost+found[root@CentOS6 ~]#ls /data &gt; f1.txt #f1为一空文件[root@CentOS6 ~]#cat f1.txtlost+found 2&gt; 把STDERR重定向到文件12345[root@CentOS6 ~]#ls /errorls: cannot access /error: No such file or directory[root@CentOS6 ~]#ls /error 2&gt; f2.txt[root@CentOS6 ~]#cat f2.txt ls: cannot access /error: No such file or directory &amp;&gt; 把所有输出重定向到文件12345[root@CentOS6 ~]#ls /data /error &amp;&gt;f3.txt[root@CentOS6 ~]#cat f3.txt ls: cannot access /error: No such file or directory/data:lost+found > 文件内容会被覆盖1234567[root@CentOS6 ~]#cat f1.txt lost+found[root@CentOS6 ~]#echo 123123[root@CentOS6 ~]#echo 123 &gt;f1.txt[root@CentOS6 ~]#cat f1.txt 123 >&gt; 原有内容基础上，追加内容12345[root@CentOS6 ~]#ls /data &gt;f1.txt [root@CentOS6 ~]#echo 123 &gt;&gt;f1.txt [root@CentOS6 ~]#cat f1.txt lost+found123 2&gt; 覆盖重定向错误输出数据流1234567[root@CentOS6 ~]#cat f2.txt ls: cannot access /error: No such file or directory[root@CentOS6 ~]#cdm-bash: cdm: command not found[root@CentOS6 ~]#cdm 2&gt; f2.txt [root@CentOS6 ~]#cat f2.txt -bash: cdm: command not found 2&gt;&gt; 追加重定向错误输出数据流1234[root@centos7 ~]#ls /error 2&gt;&gt; f2.txt[root@CentOS6 ~]#cat f2.txt -bash: cdm: command not foundls: cannot access /error: No such file or directory set –C 禁止将内容覆盖已有文件,但可追加1234567891011[root@CentOS6 ~]#cat f1.txt lost+found123[root@CentOS6 ~]#set -C[root@CentOS6 ~]#echo 345 &gt; f1.txt -bash: f1.txt: cannot overwrite existing file[root@CentOS6 ~]#echo 345 &gt;&gt; f1.txt [root@CentOS6 ~]#cat f1.txt lost+found123345 | file 强制覆盖123[root@CentOS6 ~]#echo 345 &gt;|f1.txt [root@CentOS6 ~]#cat f1.txt 345 set +C 允许覆盖1234[root@CentOS6 ~]#set +C[root@CentOS6 ~]#echo 123&gt;f1.txt[root@CentOS6 ~]#cat f1.txt 123 标准输出和错误输出各自定向至不同位置COMMAND &gt; /path/to/file.out 2&gt; /path/to/error.out123456[root@CentOS6 ~]#ls /data /error &gt;f1.txt 2&gt;f2.txt[root@CentOS6 ~]#cat f1.txt /data:lost+found[root@CentOS6 ~]#cat f2.txt ls: cannot access /error: No such file or directory 合并标准输出和错误输出为同一个数据流进行重定向 &amp;&gt; 覆盖重定向 &amp;&gt;&gt; 追加重定向 COMMAND &gt; /path/to/file.out 2&gt;&amp;1 （顺序很重要） COMMAND &gt;&gt; /path/to/file.out 2&gt;&amp;1 ()：合并多个程序的STDOUT( cal 2007 ; cal 2008 ) &gt; all.txt 重定向的实验：123456789101112131415161718192021222324252627282930313233343536373839404142434445ll a.txt b.txt 将输出一条标准输出和一条标准错误。如下：[root@CentOS6 ~]#ll a.txt-rw-r--r--. 1 root root 2 Oct 28 09:04 a.txt #这为内容A[root@CentOS6 ~]#ll b.txtls: cannot access b.txt: No such file or directory #这为内容B下面讨论各种变形的输出结果和原因：1、[root@CentOS6 ~]#ll a.txt b.txt 1&gt;file 2&gt;&amp;1[root@CentOS6 ~]#cat filels: cannot access b.txt: No such file or directory-rw-r--r--. 1 root root 2 Oct 28 09:04 a.txt file内容A和B 屏幕内容无 （因为标准输出定向到文件，标准错误定向到标准输出，所以也定向到文件）2、[root@CentOS6 ~]#ll a.txt b.txt 2&gt;&amp;1 1&gt;filels: cannot access b.txt: No such file or directory[root@CentOS6 ~]#cat file -rw-r--r--. 1 root root 2 Oct 28 09:04 a.txtfile内容A 屏幕输出B （因为标准错误重定向到了标准输出即屏幕上输出，标准输出定向到文件）3、[root@CentOS6 ~]#ll a.txt b.txt 2&gt;file 1&gt;&amp;2[root@CentOS6 ~]#cat file ls: cannot access b.txt: No such file or directory-rw-r--r--. 1 root root 2 Oct 28 09:04 a.txt file内容A和B 屏幕内容无（因为标准错误定向到文件，标准输出定向到标准错误，所以也定向到文件）4、[root@CentOS6 ~]#ll a.txt b.txt 1&gt;&amp;2 2&gt;file-rw-r--r--. 1 root root 2 Oct 28 09:04 a.txt[root@CentOS6 ~]#cat file ls: cannot access b.txt: No such file or directory file内容A 屏幕输出B（因为标准输出定向到了标准错误即屏幕，标准错误定向到文件）5、[root@CentOS6 ~]#ll a.txt b.txt 1&gt;file 1&gt;&amp;2ls: cannot access b.txt: No such file or directory-rw-r--r--. 1 root root 2 Oct 28 09:04 a.txt[root@CentOS6 ~]#cat file [root@CentOS6 ~]# file内容无 屏幕内容A和B （因为标准输出定向到文件，标准输出又定向的标准错误即屏幕，覆盖了1&gt;file，所以file内容无）6、[root@CentOS6 ~]#ll a.txt b.txt 2&gt;file 2&gt;&amp;1ls: cannot access b.txt: No such file or directory-rw-r--r--. 1 root root 2 Oct 28 09:04 a.txt[root@CentOS6 ~]#cat file [root@CentOS6 ~]# file内容无 屏幕内容A和B （因为标准错误定向到文件，标准错误又定向到标准输出即屏幕，覆盖了2&gt;file，所以file内容无） 输入重定向使用 &lt; 来重定向标准输入 某些命令能够接受从文件中导入的STDIN 12tr 'a-z' 'A-Z'&lt; /etc/issue # 该命令会把/etc/issue中的小写字符都转换成写写字符tr -d 'abc' &lt; /etc/fstab 删除fstab文件中的所有abc中任意字符 键盘输入 1234cat &gt; filemagewangxiaochun按ctrl+d离开 可以使用文件来代替键盘的输入 1Cat &gt; filea &lt; fileb #把fileb的文件内容重定向输入到filea中 把多行发送给STDIN使用“&lt;&lt;终止词”命令从键盘把多行重导向给STDIN,直到 终止词 位置的所有文本都发送给STDIN有时被称为就地文本（heretext） 12345678mail -s "Please Call" &lt;&lt;END&gt; Hi,&gt;&gt; Please give me a call when you get in. We may need&gt; to do some maintenance on server1.&gt;&gt; Details when you're on-site&gt; END tr命令转换和删除字符 语法： tr [OPTION]… SET1 [SET2]选项：​ -c 或 ——complerment：取代所有不属于第一字符集的字符；​ -d 或 ——delete：删除所有属于第一字符集的字符；​ -s 或 –squeeze-repeats：把连续重复的字符以单独一个字符表示；​ -t 或 –truncate-set1：先删除第一字符集较第二字符集多出的字符。 [:alnum:]：字母和数字[:alpha:]：字母[:cntrl:]：控制（非打印）字符[:digit:]：数字[:graph:]：图形字符[:lower:]：小写字母[:print:]：可打印字符[:punct:]：标点符号[:space:]：空白字符[:upper:]：大写字母[:xdigit:]：十六进制字符 实例：​ # echo “TANK” |tr A-Z a-z #大写字母转小写​ # echo “hello 123 world 456” | tr -d ‘0-9’ #删除字符串中的数字​ # cat text | tr ‘\t’ ‘ ‘ #将制表符转换成空格​ # echo “aa.,a 1 b#$bb 2 c*/cc 3 ddd 4” | tr -dc ‘0-9 \n’ # 删除除数字外的字符​ # tr ‘[:lower:]’ ‘[:upper:]’ #将小写字符转换成大写字符 管道连接程序，实现将前一个命令的输出直接定向后一个程序当作输入数据流管道左边的命令必须要有标准输出的功能，管道右边的命令一道要有标准输入功能的否者没有意义。 管道（使用符号“|”表示）用来连接命令命令1 | 命令2 | 命令3 | … 将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT发送到命令3的STDINSTDERR默认不能通过管道转发，可利用2&gt;&amp;1 或 |&amp; 实现最后一个命令会在当前shell进程的子shell进程中执行用来组合多种工具的功能ls | tr ‘a-z’ ‘A-Z123456less ：一页一页地查看输入 ls -l /etc | lessmail： 通过电子邮件发送输入 echo "test email" | mail -s "test" user@example.com lpr：把输入发送给打印机 echo "test print" | lpr -P printer_name 重定向到多个目标（tee）命令1 | tee [-a ] 文件名 | 命令2把命令1的STDOUT保存在文件中，做为命令2的输入-a 追加 使用： 保存不同阶段的输出复杂管道的故障排除同时查看和记录输出 练习 将/etc/issue文件中的内容转换为大写后保存至/tmp/issue.out文件中 1cat /etc/issue | tr "[a-z]" "[A-Z]" &gt;/tmp/issue.out 将当前系统登录用户的信息转换为大写后保存至/tmp/who.out文件中 1who | tr "[a-z]" "[A-Z]" &gt;/tmp/who.out 一个linux用户给root发邮件，要求邮件标题为”help”，邮件正文如下：Hello, I am 用户名,The system version is here,pleasehelp me to check it ,thanks! 操作系统版本信息 12345mail -s "root" &lt;&lt;EOF&gt; hello,i am $user&gt; The system version is here,please help me to check it,thanks!&gt;cat /etc/centos-release&gt;EOF 将/root/下文件列表，显示成一行，并文件名之间用空格隔开 1ls /root | tr "\n" " " 计算1+2+3+..+99+100的总和 1echo &#123;1..100&#125; | tr -s " " "+" | bc 删除Windows文本文件中的‘^M’字符 1tr -d "\15" win.txt 处理字符串“xt.,l 1 jr#!$mn2 c*/fe3 uz4”，只保留其中的数字和空格 123echo "xt.,l 1 jr#bcmn2 c*/fe3 uz4" | tr -d "[[:alpha:]]" | tr -d "[[:punct:]]" 或者echo "xt.,l 1 jr#bcmn2 c*/fe3 uz4" |tr -dc "[:digit:][:space:]" 将PATH变量每个目录显示在独立的一行 1echo $PATH |tr -s ":" "\n" 将指定文件中0-9分别替代成a-j 123先创建文件touch f1 给f1 vim 输入0-9 cat f1 | tr "[0-9]" "[a-j]" 将文件/etc/centos-release中每个单词（由字母组成）显示在独立一行，并无空行 1cat /etc/centos-release | tr -s " " "\n"]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>IO</tag>
        <tag>管道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Linux basics]]></title>
    <url>%2F2017%2F12%2F20%2FHello%20Linux%20basics%2F</url>
    <content type="text"><![CDATA[计算机硬件组成&ensp;&ensp;&ensp;&ensp;根据冯·诺依曼体系结构，我们知道现代计算机硬件由控制器、运算器、存储器、输入设备和输出设备五大部分组成。&ensp;&ensp;&ensp;&ensp;控制器：控制器是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，并根据具体要求进行控制、调度程序、数据、地址，协调计 算机各个部分工作，协调计算机各部分工作及内存、IO设备等的访问&ensp;&ensp;&ensp;&ensp;运算器：对数据进行各种算数运算和逻辑运算也就是对数据进行加工，在现代计算机系统中将控制器和运算器合并在一起组成CPU。&ensp;&ensp;&ensp;&ensp;存储器：存储器是存储程序、数据和各种信号、命令等信息，并在需要的时候提供这些信息；在现代计算机系统中就是内存。&ensp;&ensp;&ensp;&ensp;输入设备:就是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机；比如键盘、鼠标等&ensp;&ensp;&ensp;&ensp;输出设备：就是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息进行输出；比如显示器、打印机等 Linux发行版 slackware: SUSE Linux Enterprise Server (SLES) OpenSuse桌面 debian: ubuntu mint redhat: RedHat Enterprise Linux:红帽推出的收费的技术支持和更新的linux发行版，适用于企业服务器版Linux，稳定、安全。 CentOS:centos可以说是社区维护的RHEL克隆版本，免费使用。 Fedora:由社区维护的适用于个人桌面的Linux发行版 ArchLinux: 轻量简洁Gentoo: 极致性能，不提供传统意义的安装程序LFS: Linux From scratch 自制LinuxAndroid: kernel+busybox（工具集）+java虚拟机 Linux的哲学思想 一切都是一个文件（包括硬件) 小型，单一用途的程序 链接程序，共同完成复杂的任务 避免令人困惑的用户界面 配置数据存储在文本中命令echo主要是用于显示信息的1234567891011121314151617181920212223242526[root@CentOS7 data]#man echoECHO(1) User Commands ECHO(1)NAME echo - display a line of textSYNOPSIS echo [SHORT-OPTION]... [STRING]... echo LONG-OPTIONDESCRIPTION Echo the STRING(s) to standard out‐ put. -n do not output the trailing newline -e enable interpretation of backslash escapes -E disable interpretation of backslash escapes (default) --help display this help and exit --version 下面说明一些重要参数： -E （默认）不支持\解释功能 -n 不自动换行 -e 启用\字符的解释功能 启用命令选项-e，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出 \a 发出警告声 \b 退格键 \c 最后不加上换行符号 \n 换行且光标移至行首 \r 回车，即光标移至行首，但不换行 \t 插入tab \ \ 插入\字符 \0nnn 插入nnn（八进制）所代表的ASCII字符 \xHH 插入HH（十六进制）所代表的ASCII数字（man 7 ascii） date主要是显示操作系统的时间1234[root@CentOS7 data]#date --helpUsage: date [OPTION]... [+FORMAT] or: date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]Display the current time in the given FORMAT, or set the system date 下面说明一些重要参数： -d 显示字符串所指的日期与时间,如果不指定，默认为当前系统时间。 12[root@CentOS7 data]#dateSun Sep 23 15:12:28 CST 2018 -s 根据字符串指定的日期、时间设定为当前的系统时间。 -d @ 把秒转化成具体的年月日，从1970年1月1号00：00:00算起12[root@CentOS7 data]#date -d @1537687300Sun Sep 23 15:21:40 CST 2018 如果需要以指定的格式显示日期或者日期，可以使用date “+”开头的字符串指定其格式，最常用的格式如下:%n : 下一行%t : 跳格%H : 小时(00-23)%M : 分钟(00-59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00-60)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区%d : 日 (01-31)%D : 直接显示日期 (mm/dd/yy))%m : 月份 (01-12)%Y : 完整年份 (0000-9999)%F : full date;相当于年月日12[root@CentOS7 data]#date +"%F %T"2018-09-23 15:33:21 history主要显示历史命令记录，或者下达历史纪录中的指令123456[root@CentOS7 data]#help historyhistory: history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...] Display or manipulate the history list. Display the history list with line numbers, prefixing each modified entry with a `*'. An argument of N lists only the last N entries. 其中一些重要的参数：n 数字,表示要列出最近的 n 条历史-c ：清空命令历史-a ：追加本次会话新执行的命令历史列表至历史文件-r ：读历史文件附加到历史列表-w ：保存历史列表到指定的历史文件-n: 读历史文件中未读过的行到历史列表-p: 展开历史参数成多行，但不存在历史列表中-s: 展开历史参数成一行，附加在历史列表后1234567[root@CentOS7 ~]#cat .bash_history exithistoryuname -rcat /etc/centos-releasehistoryexit 上图可以查看文件中的历史 Bash的快捷键 Ctrl + l 清屏，相当于clear命令 Ctrl + o 执行当前命令，并重新显示本命令 Ctrl + s 阻止屏幕输出，锁定 Ctrl + q 允许屏幕输出 Ctrl + c 终止命令 Ctrl + z 挂起命令 Ctrl + a 光标移到命令行首，相当于Home Ctrl + e 光标移到命令行尾，相当于End Ctrl + f 光标向右移动一个字符，相当于右方向键 Ctrl + b 光标向左移动一个字符，相当于左方向键 Alt + f 光标向右移动一个单词尾 Alt + b 光标向左移动一个单词首 Ctrl + x x光标在命令行首和光标之间移动 Ctrl + u 从光标处删除至命令行首 Ctrl + k 从光标处删除至命令行尾 Alt + r 删除当前整行 Ctrl + w 从光标处向左删除至单词首 Alt + d 从光标处向右删除至单词尾 Ctrl + d 删除光标处的一个字符 Ctrl + h 删除光标前的一个字符 Ctrl + y 将删除的字符粘贴至光标后 Alt + c 从光标处开始向右更改为首字母大写的单词 Alt + u 从光标处开始，将右边一个单词更改为大写 Alt + l 从光标处开始，将右边一个单词更改为小写 Ctrl + t 交换光标处和之前的字符位置 Alt + t 交换光标处和之前的单词位置 Alt + N 提示输入指定字符后，重复显示该字符N次]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
</search>
